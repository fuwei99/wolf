<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI ç‹¼äººæ€ - å®Œæ•´åŠŸèƒ½ç‰ˆ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --bg-color: #121212;
            --card-bg: #1e1e2e;
            --accent: #ff0055;
        }

        body {
            background-color: var(--bg-color);
            color: #e0e0e0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            padding-bottom: 120px;
        }

        /* Animations */
        @keyframes blink {
            50% {
                opacity: 0;
            }
        }

        .cursor::after {
            content: 'â–‹';
            animation: blink 1s infinite;
            color: var(--accent);
            margin-left: 2px;
        }

        .role-card {
            transition: all 0.3s;
            border: 1px solid #333;
            overflow: hidden;
        }

        .role-card.active {
            border-color: #4cc9f0;
            box-shadow: 0 0 15px rgba(76, 201, 240, 0.3);
            transform: scale(1.02);
            z-index: 10;
        }

        .role-card.dead {
            opacity: 0.4;
            filter: grayscale(100%);
            border-color: #333;
            background: #000;
        }

        .role-card.dead span {
            text-decoration: line-through;
        }

        /* Logs & Thoughts */
        .log-container {
            mask-image: linear-gradient(to bottom, transparent, black 2%);
            -webkit-mask-image: linear-gradient(to bottom, transparent, black 2%);
        }

        .log-entry {
            margin-bottom: 8px;
            padding: 8px 10px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.03);
            font-size: 0.85rem;
            line-height: 1.5;
            border-left: 3px solid #555;
        }

        .log-public {
            border-color: #f72585;
        }

        .log-private {
            border-color: #4cc9f0;
            background: rgba(76, 201, 240, 0.05);
        }

        .log-sys {
            border-color: #ffe600;
            color: #ffe600;
            font-weight: bold;
            text-align: center;
            background: rgba(255, 230, 0, 0.05);
        }

        /* Folded Thoughts */
        details.thought-bubble {
            margin-bottom: 4px;
            border: 1px dashed #444;
            border-radius: 4px;
            padding: 4px;
            background: #00000030;
        }

        details.thought-bubble summary {
            cursor: pointer;
            font-size: 0.7rem;
            color: #888;
            font-family: monospace;
            outline: none;
            user-select: none;
        }

        details.thought-bubble summary:hover {
            color: #aaa;
        }

        .thought-content {
            color: #aaa;
            font-size: 0.75rem;
            font-family: monospace;
            white-space: pre-wrap;
            margin-top: 4px;
            border-top: 1px solid #333;
            padding-top: 4px;
        }

        /* Modals */
        .modal {
            transition: opacity 0.2s;
            pointer-events: none;
            opacity: 0;
            z-index: 100;
        }

        .modal.active {
            pointer-events: auto;
            opacity: 1;
        }

        .btn-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            border-radius: 6px;
            background: #1f2937;
            color: white;
            border: 1px solid #374151;
        }

        .btn-icon:active {
            transform: scale(0.95);
        }

        /* Streaming Box */
        .think-text {
            color: #6b7280;
            font-style: italic;
        }

        .json-text {
            color: #4ade80;
        }
    </style>
</head>

<body class="text-sm antialiased select-none">

    <!-- Top Bar -->
    <div
        class="p-2 bg-gray-900/95 backdrop-blur fixed top-0 w-full z-50 border-b border-gray-800 flex justify-between items-center">
        <div class="flex items-center gap-2">
            <button onclick="resetGame()"
                class="btn-icon text-red-400 border-red-900 bg-red-900/10 h-8 w-16 text-xs font-bold gap-1">
                <span>ğŸ”„</span>é‡å¼€
            </button>
            <div class="flex flex-col">
                <h1 class="font-bold text-transparent bg-clip-text bg-gradient-to-r from-pink-500 to-purple-500">AI ç‹¼äººæ€
                    Pro+</h1>
                <span id="phaseDisplay" class="text-[9px] text-gray-400 font-mono leading-none">å‡†å¤‡ä¸­</span>
            </div>
        </div>
        <div class="flex gap-2">
            <button onclick="undoStep()" id="btnUndo"
                class="btn-icon text-yellow-400 border-yellow-900 hover:bg-yellow-900/20">â†©ï¸</button>
            <button onclick="openSaveModal()"
                class="btn-icon text-green-400 border-green-900 hover:bg-green-900/20">ğŸ’¾</button>
            <button onclick="openLoadModal()"
                class="btn-icon text-blue-400 border-blue-900 hover:bg-blue-900/20">ğŸ“‚</button>
            <button onclick="toggleSettings()" class="btn-icon text-gray-300 hover:bg-gray-700">âš™ï¸</button>
        </div>
    </div>

    <div class="pt-14 px-2">
        <!-- Action Bar -->
        <div class="flex gap-2 mb-3">
            <button id="btnStart" onclick="startGame()"
                class="flex-1 bg-green-700 hover:bg-green-600 py-3 rounded font-bold shadow text-white transition transform active:scale-95">å¼€å§‹æ–°æ¸¸æˆ</button>
            <button id="btnStep" onclick="gameStep()" disabled
                class="flex-1 bg-indigo-600 hover:bg-indigo-500 py-3 rounded font-bold text-white disabled:opacity-20 disabled:cursor-not-allowed transition active:scale-95">ä¸‹ä¸€æ­¥</button>
            <div class="flex items-center justify-center px-3 bg-gray-800 rounded text-xs border border-gray-700"
                onclick="toggleAuto()">
                <input type="checkbox" id="autoPlay" class="pointer-events-none w-4 h-4 accent-pink-500">
                <span class="ml-1 font-bold text-gray-300">è‡ªåŠ¨</span>
            </div>
        </div>

        <!-- Stream Output -->
        <div class="mb-4 relative group">
            <div class="flex justify-between text-[10px] text-gray-400 mb-1 pl-1 uppercase tracking-widest">
                <span>ğŸ‘ï¸ å®æ—¶æ€ç»´æµ (<span id="activePlayerName">...</span>)</span>
                <span id="retryIndicator" class="text-yellow-500 hidden blink">âš ï¸ ç½‘ç»œé‡è¯•ä¸­...</span>
            </div>
            <div id="streamingOutput"
                class="bg-[#0b0b12] border border-[#2d2d44] shadow-inner min-h-[100px] max-h-[180px] overflow-y-auto rounded-lg p-3 text-xs font-mono leading-relaxed">
                <span class="text-gray-600">ç­‰å¾…æ¸¸æˆå¼€å§‹...</span>
            </div>
        </div>

        <!-- Players -->
        <div id="playersGrid" class="grid grid-cols-4 gap-2 mb-4 transition-all"></div>

        <!-- Logs -->
        <div class="flex justify-between items-end mb-2 px-1">
            <h3 class="font-bold text-gray-400 text-xs uppercase tracking-wider">ä¸Šå¸æ—¥å¿—</h3>
            <button onclick="clearLogs()" class="text-[10px] text-gray-600 hover:text-gray-300">æ¸…ç©º</button>
        </div>
        <div id="gameLog"
            class="log-container flex flex-col-reverse h-[35vh] overflow-y-auto bg-gray-900/50 rounded-lg p-2 border border-gray-800/50">
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal fixed inset-0 flex items-center justify-center bg-black/80 backdrop-blur-sm">
        <div class="bg-gray-800 w-[90%] max-w-md h-[80vh] rounded-xl border border-gray-700 flex flex-col shadow-2xl">
            <div class="p-4 border-b border-gray-700 flex justify-between items-center bg-gray-900/50 rounded-t-xl">
                <h2 class="font-bold text-white">è®¾ç½®</h2>
                <button onclick="toggleSettings()" class="text-2xl text-gray-400">&times;</button>
            </div>
            <div class="flex-1 overflow-y-auto p-4 space-y-4">
                <!-- API -->
                <div class="space-y-2">
                    <label class="text-xs font-bold text-pink-400 uppercase">API Config</label>
                    <input type="text" id="apiBase" onchange="saveGlobalSettings()" placeholder="Base URL"
                        class="w-full bg-black/30 border border-gray-600 rounded p-2 text-xs text-white font-mono">
                    <input type="password" id="apiKey" onchange="saveGlobalSettings()" placeholder="API Key"
                        class="w-full bg-black/30 border border-gray-600 rounded p-2 text-xs text-white font-mono">
                    <button onclick="fetchModels()"
                        class="w-full bg-gray-700 text-xs py-2 rounded hover:bg-gray-600">åˆ·æ–°æ¨¡å‹åˆ—è¡¨</button>
                </div>
                <div class="border-t border-gray-700 my-2"></div>
                <!-- Prompt -->
                <div class="space-y-2">
                    <label class="text-xs font-bold text-blue-400 uppercase">Prompt Editor</label>

                    <!-- Preset Controls -->
                    <div class="flex gap-1 mb-2">
                        <select id="presetSelect"
                            class="bg-black/30 border border-gray-600 rounded p-1 text-xs text-gray-300 flex-1">
                            <option value="">-- é€‰æ‹©é¢„è®¾ --</option>
                        </select>
                        <button onclick="loadPreset()"
                            class="btn-icon w-8 h-8 text-blue-400 border-blue-900">ğŸ“‚</button>
                        <button onclick="savePreset()"
                            class="btn-icon w-8 h-8 text-green-400 border-green-900">ğŸ’¾</button>
                        <button onclick="deletePreset()"
                            class="btn-icon w-8 h-8 text-red-400 border-red-900">ğŸ—‘ï¸</button>
                    </div>

                    <select id="promptSelect" onchange="loadPromptToEdit()"
                        class="w-full bg-black/30 border border-gray-600 rounded p-1 text-xs text-gray-300 mb-1"></select>
                    <textarea id="promptText" onchange="saveCurrentPrompt()"
                        class="w-full h-32 bg-black/30 border border-gray-600 rounded p-2 text-[10px] text-gray-300 font-mono leading-relaxed"></textarea>
                    <button onclick="resetPrompts()"
                        class="w-full border border-red-900 text-red-400 text-xs py-2 rounded hover:bg-red-900/20">é‡ç½®ä¸ºé»˜è®¤
                        Prompt</button>
                </div>
                <div class="border-t border-gray-700 my-2"></div>
                <!-- Role Config -->
                <div class="flex justify-between items-center mb-2">
                    <label class="text-xs font-bold text-green-400 uppercase">Role Config (<span
                            id="playerCountDisplay">8</span>)</label>
                    <div class="flex gap-1">
                        <button onclick="adjustPlayerCount(-1)"
                            class="px-2 py-1 bg-gray-700 rounded text-xs hover:bg-gray-600">-</button>
                        <button onclick="adjustPlayerCount(1)"
                            class="px-2 py-1 bg-gray-700 rounded text-xs hover:bg-gray-600">+</button>
                    </div>
                </div>
                <div id="roleConfigList" class="space-y-1"></div>
            </div>
        </div>
    </div>

    <!-- Load/Save Modal -->
    <div id="loadModal" class="modal fixed inset-0 flex items-center justify-center bg-black/90 backdrop-blur z-[110]">
        <div class="bg-gray-900 w-[85%] max-w-sm rounded-xl border border-gray-700 p-4 shadow-2xl">
            <h2 class="font-bold text-white mb-4 flex justify-between">
                <span>å­˜æ¡£åˆ—è¡¨</span>
                <button onclick="closeLoadModal()" class="text-gray-400">&times;</button>
            </h2>
            <button onclick="saveNewSlot()" id="btnSaveNew"
                class="w-full bg-green-800/50 border border-green-600 text-green-100 py-2 rounded mb-3 text-xs flex justify-center items-center gap-2">
                <span>â•</span> æ–°å»ºå­˜æ¡£
            </button>
            <div id="saveSlotList" class="max-h-[60vh] overflow-y-auto space-y-2"></div>
        </div>
    </div>

    <script>
        /**
         * 1. CONFIG & CONSTANTS
         */
        const DEFAULT_ROLES = ['ç‹¼äºº', 'ç‹¼äºº', 'é¢„è¨€å®¶', 'å¥³å·«', 'çŒäºº', 'å®ˆå«', 'æ‘æ°‘', 'æ‘æ°‘'];
        let appConfig = {
            apiBase: "",
            apiKey: "",
            maxRetries: 3,
            prompts: {}, // Will load from server
            rolesSetup: [...DEFAULT_ROLES],
            modelsSetup: Array(8).fill('gpt-3.5-turbo')
        };

        // History for Undo
        let historyStack = [];

        // Current State
        let gameState = {
            status: 'setup', dayCount: 0, phase: 'night', subPhase: 'init',
            logs: [], settings: { potion: { save: true, harm: true } },
            guardLast: -1, nightTarget: -1, witchAct: { save: false, harmTarget: -1 }
        };
        let players = [];
        let availableModels = ['gpt-3.5-turbo', 'gpt-4o-mini'];
        let isStreaming = false;
        let hasStorage = false;

        /**
         * 2. CORE INIT
         */
        async function init() {
            await loadGlobalSettings();
            await resetPrompts(false); // Load default prompts initially without saving
            initRoleConfig();
            updatePromptEditorList();
            refreshPresetList();
        }

        async function loadGlobalSettings() {
            try {
                const res = await fetch('/api/config');
                const data = await res.json();
                appConfig.apiBase = data.apiBase;
                appConfig.apiKey = data.apiKey;
                if (data.rolesSetup) appConfig.rolesSetup = data.rolesSetup;
                if (data.modelsSetup) appConfig.modelsSetup = data.modelsSetup;

                document.getElementById('apiBase').value = appConfig.apiBase;
                document.getElementById('apiKey').value = appConfig.apiKey;
            } catch (e) { console.error("Failed to load config", e); }
        }

        async function saveGlobalSettings() {
            appConfig.apiBase = document.getElementById('apiBase').value;
            appConfig.apiKey = document.getElementById('apiKey').value;
            try {
                await fetch('/api/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        apiBase: appConfig.apiBase,
                        apiKey: appConfig.apiKey,
                        rolesSetup: appConfig.rolesSetup,
                        modelsSetup: appConfig.modelsSetup
                    })
                });
            } catch (e) { console.error("Failed to save config", e); }
        }

        /**
         * 3. SAVE / LOAD / UNDO
         */
        function pushHistory() {
            // Save snapshot before change
            const snapshot = JSON.stringify({ gameState, players });
            historyStack.push(snapshot);
            if (historyStack.length > 20) historyStack.shift(); // Max 20 steps

            // Auto Save to latest
            performSave('autosave');
        }

        function undoStep() {
            if (historyStack.length === 0) return alert("æ— æ³•å†å›é€€äº†");
            const prev = JSON.parse(historyStack.pop());
            gameState = prev.gameState;
            players = prev.players;

            // Refresh UI
            document.getElementById('gameLog').innerHTML = '';
            gameState.logs.forEach(l => addLogToDom(l));
            renderGrid();
            updateHeader();
            addLog("â†©ï¸ æ—¶å…‰å€’æµï¼Œå›åˆ°äº†ä¸Šä¸€æ­¥ã€‚", "sys");
        }

        function openSaveModal() {
            document.getElementById('loadModal').classList.add('active');
            document.getElementById('btnSaveNew').style.display = 'flex';
            renderSaveList(true); // Show save mode
        }

        function openLoadModal() {
            document.getElementById('loadModal').classList.add('active');
            document.getElementById('btnSaveNew').style.display = 'none';
            renderSaveList(false); // Show load mode
        }

        function closeLoadModal() {
            document.getElementById('loadModal').classList.remove('active');
        }

        async function renderSaveList(isSaveMode) {
            const list = document.getElementById('saveSlotList');
            list.innerHTML = '<div class="text-gray-500 text-center">åŠ è½½ä¸­...</div>';

            try {
                const res = await fetch('/api/saves');
                const files = await res.json();
                list.innerHTML = '';

                files.forEach(f => {
                    createSlotUI(list, f, f, isSaveMode);
                });

                if (files.length === 0) {
                    list.innerHTML = '<div class="text-gray-500 text-center">æš‚æ— å­˜æ¡£</div>';
                }
            } catch (e) {
                list.innerHTML = '<div class="text-red-500 text-center">åŠ è½½å¤±è´¥</div>';
            }
        }

        function createSlotUI(container, filename, label, isSaveMode) {
            const div = document.createElement('div');
            div.className = "bg-gray-800 p-2 rounded border border-gray-700 flex justify-between items-center";

            const btn = document.createElement('button');
            btn.className = "text-xs text-left flex-1 text-gray-300 hover:text-white";
            btn.innerText = label;

            if (isSaveMode) {
                btn.onclick = () => { if (confirm("è¦†ç›–æ­¤å­˜æ¡£?")) performSave(filename); };
            } else {
                btn.onclick = () => performLoad(filename);
            }

            const del = document.createElement('button');
            del.className = "ml-2 text-red-500 px-2 hover:text-red-400 text-xs";
            del.innerText = "ğŸ—‘ï¸";
            del.onclick = async (e) => {
                e.stopPropagation();
                if (confirm("ç¡®å®šåˆ é™¤?")) {
                    await fetch(`/api/saves/${filename}`, { method: 'DELETE' });
                    renderSaveList(isSaveMode);
                }
            };

            div.appendChild(btn);
            div.appendChild(del);
            container.appendChild(div);
        }

        function saveNewSlot() {
            const name = prompt("è¯·è¾“å…¥å­˜æ¡£åç§°:", `save_${Date.now()}`);
            if (name) performSave(name);
        }

        async function performSave(filename) {
            const data = { gameState, players };
            try {
                await fetch(`/api/saves/${filename}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                closeLoadModal();
                // alert("å­˜æ¡£æˆåŠŸ!"); // Disable alert for autosave
                if (filename !== 'autosave') alert("å­˜æ¡£æˆåŠŸ!");
            } catch (e) { if (filename !== 'autosave') alert("å­˜æ¡£å¤±è´¥"); }
        }

        async function performLoad(filename) {
            try {
                const res = await fetch(`/api/saves/${filename}`);
                if (!res.ok) throw new Error("Load failed");
                const d = await res.json();

                historyStack = [];
                gameState = d.gameState;
                players = d.players;

                document.getElementById('gameLog').innerHTML = '';
                gameState.logs.forEach(l => addLogToDom(l));
                renderGrid();
                updateHeader();
                document.getElementById('btnStart').classList.add('hidden');
                document.getElementById('btnStep').disabled = false;

                closeLoadModal();
                addLog(`ğŸ“‚ è¯»æ¡£æˆåŠŸ: ${filename}`, "sys");
            } catch (e) { alert("è¯»æ¡£å¤±è´¥"); }
        }

        function resetGame() {
            document.getElementById('autoPlay').checked = false;
            isStreaming = false;

            gameState = {
                status: 'setup', dayCount: 0, phase: 'night', subPhase: 'init',
                logs: [], settings: { potion: { save: true, harm: true } },
                guardLast: -1, nightTarget: -1, witchAct: { save: false, harmTarget: -1 }
            };
            players = [];
            historyStack = [];

            document.getElementById('gameLog').innerHTML = '';
            document.getElementById('playersGrid').innerHTML = '';
            document.getElementById('phaseDisplay').innerText = 'å‡†å¤‡ä¸­';
            document.getElementById('activePlayerName').innerText = '...';
            document.getElementById('streamingOutput').innerHTML = '<span class="text-gray-600">ç­‰å¾…æ¸¸æˆå¼€å§‹...</span>';

            document.getElementById('btnStart').classList.remove('hidden');
            document.getElementById('btnStep').disabled = true;

            addLog("=== æ¸¸æˆå·²é‡ç½® ===", "sys");
        }

        /**
         * 4. GAME ENGINE
         */
        function startGame() {
            players = [];
            gameState = {
                status: 'playing', dayCount: 1, phase: 'night', subPhase: 'wolf',
                logs: [], settings: { potion: { save: true, harm: true } },
                guardLast: -1, nightTarget: -1, witchAct: { save: false, harmTarget: -1 }
            };
            historyStack = [];
            document.getElementById('gameLog').innerHTML = '';

            const count = appConfig.rolesSetup.length;
            const w = [];

            // 1. Collect Config
            for (let i = 0; i < count; i++) {
                const r = document.getElementById(`role-${i}`).value;
                if (r === 'ç‹¼äºº') w.push(i);
                players.push({
                    id: i, role: r, model: document.getElementById(`model-${i}`).value,
                    alive: true, privateMem: [], avatar: getAvatar(r)
                });
            }

            // 2. Validation
            const good = players.filter(p => p.role !== 'ç‹¼äºº');
            if (w.length < 1 || good.length < 1) {
                alert("é…ç½®é”™è¯¯ï¼šè‡³å°‘éœ€è¦ 1 ä¸ªç‹¼äººå’Œ 1 ä¸ªå¥½äººï¼");
                return;
            }

            // 3. Init Memory
            players.forEach(p => {
                let m = `ä½ çš„ç¼–å·æ˜¯ ${p.id + 1}å·ã€‚èº«ä»½: ${p.role}ã€‚`;
                if (p.role === 'ç‹¼äºº') {
                    const mates = w.filter(x => x !== p.id).map(x => `${x + 1}å·`).join(', ');
                    m += ` é˜Ÿå‹: ${mates || 'æ— '}ã€‚`;
                }
                p.privateMem.push(m);
            });

            renderGrid();
            addLog("=== æ¸¸æˆå¼€å§‹ ===", "sys");
            document.getElementById('btnStart').classList.add('hidden');
            document.getElementById('btnStep').disabled = false;
            updateHeader();
            pushHistory();
            if (document.getElementById('autoPlay').checked) gameStep();
        }

        async function gameStep() {
            if (gameState.status === 'gameover' || isStreaming) return;

            pushHistory(); // Snapshot state before moving

            try {
                await processPhase();
            } catch (e) {
                console.error(e);
                addLog(`âŒ é”™è¯¯: ${e.message}`, "sys");
                isStreaming = false;
                document.getElementById('autoPlay').checked = false;
            }
            renderGrid();

            if (gameState.status !== 'gameover' && document.getElementById('autoPlay').checked) {
                setTimeout(gameStep, 1500);
            }
        }

        async function processPhase() {
            const w = players.filter(p => p.alive && p.role === 'ç‹¼äºº');
            const h = players.filter(p => p.alive && p.role !== 'ç‹¼äºº');
            if (w.length === 0) return gameOver(true);
            if (w.length >= h.length) return gameOver(false);

            switch (gameState.subPhase) {
                case 'wolf': await runWolf(); break;
                case 'seer': await runRole('é¢„è¨€å®¶', 'seer_night'); break;
                case 'guard': await runRole('å®ˆå«', 'guard_night'); break;
                case 'witch': await runWitch(); break;
                case 'morning': resolveMorning(); break;
                case 'discuss': await runDiscuss(); break;
                case 'vote': await runVote(); break;
            }
        }

        /**
         * 5. STREAMING & PARSING (CoT Logic)
         */
        async function streamLLM(player, key, instruct) {
            if (!player.alive) return null;

            document.getElementById('activePlayerName').innerText = `${player.id + 1}å·`;
            const card = document.getElementById(`card-${player.id}`);
            if (card) card.classList.add('active');
            isStreaming = true;

            let final = "";
            const outEl = document.getElementById('streamingOutput');
            outEl.innerHTML = ''; // Clear prev

            // Convert internal 0-based IDs to 1-based for Prompt
            const aliveList = players.filter(p => p.alive).map(p => `${p.id + 1}å·`).join(', ');

            // Filter logs: Only show public logs to everyone.
            // Private logs are strictly hidden from LLM context unless it's their own memory (which is handled by privateMem).
            const publicLogs = gameState.logs.filter(l => l.type === 'public').slice(-15).map(l => l.content).join('\n');

            const context = `
[Public History]
${publicLogs}
[Private Memory]
${player.privateMem.join('\n')}
[Alive Players]
${aliveList}
[System]
Current Phase: ${gameState.subPhase}
Instruction: ${instruct}`;

            const sys = appConfig.prompts.common + "\n" + appConfig.prompts[key];

            try {
                const res = await fetch(`${appConfig.apiBase}/chat/completions`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${appConfig.apiKey}` },
                    body: JSON.stringify({
                        model: player.model,
                        messages: [{ role: 'system', content: sys }, { role: 'user', content: context }],
                        temperature: 0.7,
                        max_tokens: 4096, // HUGE TOKEN LIMIT
                        stream: true
                    })
                });

                if (!res.ok) throw new Error(`API Error ${res.status}`);

                const reader = res.body.getReader();
                const decoder = new TextDecoder();

                let buffer = "";

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');
                    for (const line of lines) {
                        if (line.startsWith('data: ') && line !== 'data: [DONE]') {
                            try {
                                const txt = JSON.parse(line.slice(6)).choices[0].delta.content || "";
                                final += txt;
                                buffer = final;

                                // Visual Formatting for Thinking
                                let displayHtml = escapeHtml(final);
                                // 
                                tags
                                displayHtml = displayHtml.replace(/<think>/g, '<span class="think-text"><think>');
                                displayHtml = displayHtml.replace(/<\/think>/g, '</think></span>');
                                // Highlights JSON keys
                                displayHtml = displayHtml.replace(/"thought":/g, '<span class="think-text">"thought":</span>');
                                displayHtml = displayHtml.replace(/"action":/g, '<span class="json-text">"action":</span>');

                                outEl.innerHTML = displayHtml + '<span class="cursor"></span>';
                                outEl.scrollTop = outEl.scrollHeight;
                            } catch (e) { }
                        }
                    }
                }

            } catch (e) {
                console.error(e);
                final = `{"error": "failed"}`;
            }

            isStreaming = false;
            if (card) card.classList.remove('active');

            player.privateMem.push(`(Self): ${extractActionSummary(final)}`);
            return final;
        }

        function extractActionSummary(text) {
            // Helper to store short memory not the huge thought chain
            const json = parseMixedOutput(text);
            if (!json) return "Acted.";
            if (json.speech) return `Speech: ${json.speech.substring(0, 20)}...`;
            if (json.action) return `Action: ${json.action} -> ${json.target}`;
            return "Acted.";
        }

        /**
         * SMART PARSER: Handles Thought Fields & Tags
         */
        function parseMixedOutput(text) {
            try {
                // 0. Try to extract from markdown code blocks (find ALL, use LAST valid)
                const codeBlockRegex = /```(?:json)?\s*([\s\S]*?)\s*```/g;
                const matches = [...text.matchAll(codeBlockRegex)];

                if (matches.length > 0) {
                    // Iterate backwards to find the last valid JSON
                    for (let i = matches.length - 1; i >= 0; i--) {
                        try {
                            return JSON.parse(matches[i][1]);
                        } catch (e) {
                            // Continue to previous match
                        }
                    }
                }

                // 1. Fallback: Try to find last JSON object in raw text
                const firstBrace = text.indexOf('{');
                const lastBrace = text.lastIndexOf('}');
                if (firstBrace !== -1 && lastBrace !== -1) {
                    // Try to parse the whole block first
                    const potentialJson = text.substring(firstBrace, lastBrace + 1);
                    try {
                        return JSON.parse(potentialJson);
                    } catch (e) {
                        // If that fails, maybe there are multiple JSONs concatenated?
                        // Let's try to find the *last* valid JSON object by scanning backwards
                        // This is complex, so for now we stick to the simple extraction.
                        // A more robust way would be to use a stack-based parser, but let's hope the code block fix covers 99% cases.
                    }
                }
                return null;
            } catch (e) { return null; }
        }

        function addLog(content, type, thoughtContent = null) {
            const entry = { content, type, thought: thoughtContent };
            gameState.logs.push(entry);
            addLogToDom(entry);
        }

        function addLogToDom(entry) {
            const div = document.createElement('div');
            div.className = `log-entry log-${entry.type}`;

            // If there is thought, make a fold
            if (entry.thought) {
                const details = document.createElement('details');
                details.className = 'thought-bubble';
                details.innerHTML = `
            <summary>ğŸ’­ æ€è€ƒè¿‡ç¨‹ (ç‚¹å‡»å±•å¼€)</summary>
            <div class="thought-content">${escapeHtml(entry.thought)}</div>
        `;
                div.appendChild(details);
            }

            const text = document.createElement('div');
            text.innerText = entry.content;
            div.appendChild(text);

            const cont = document.getElementById('gameLog');
            cont.prepend(div);
        }

        function processAndLogResponse(playerId, roleName, rawText, isPublic) {
            let json = parseMixedOutput(rawText);
            let thought = null;

            // Extract thought from <think> tags if models use them
            const thinkMatch = rawText.match(/<think>([\s\S]*?)<\/think>/);
            if (thinkMatch) thought = thinkMatch[1].trim();

            if (json) {
                // Extract thought from JSON field
                if (json.thought || json.reasoning) {
                    thought = json.thought || json.reasoning;
                }

                // Construct Clean Log
                let msg = "";
                if (json.speech) userMsg = json.speech;
                else if (json.action) {
                    if (json.target !== undefined) userMsg = `æ‰§è¡Œäº† ${json.action} -> ${json.target}`;
                    else userMsg = `æ‰§è¡Œäº† ${json.action}`;
                }
                else userMsg = "è¿›è¡Œäº†æ€è€ƒ (æ— å…·ä½“è¡ŒåŠ¨)";

                // Convert target from 1-based to 0-based if present
                if (json.target !== undefined && typeof json.target === 'number') {
                    json.target = json.target - 1;
                }

                if (isPublic) {
                    msg = `${playerId + 1}å·(${roleName}): ${userMsg}`;
                } else {
                    msg = `${roleName}è¡ŒåŠ¨: ${userMsg}`;
                }

                addLog(msg, isPublic ? "public" : "private", thought);
                return json; // Return parsed action for logic
            }

            // Fallback if no JSON found
            addLog(`${playerId + 1}å· (å¼‚å¸¸è¾“å‡º): æœªæ£€æµ‹åˆ°æœ‰æ•ˆæŒ‡ä»¤`, "private", rawText);
            return null;
        }

        /**
         * 6. ROLE LOGIC WRAPPERS
         */
        async function runWolf() {
            addLog("=== å¤©é»‘è¯·é—­çœ¼ ===", "sys");
            gameState.nightTarget = -1;
            const wolves = players.filter(p => p.role === 'ç‹¼äºº' && p.alive);

            if (wolves.length === 0) {
                gameState.subPhase = 'guard';
                return;
            }

            // Wolf Discussion Phase
            let round = 0;
            let readyToVote = false;
            const maxRounds = 3;

            addLog(`ğŸº ç‹¼äººå¼€å§‹è¡ŒåŠ¨ (å­˜æ´»: ${wolves.map(p => p.id + 1).join(',')})`, "private");

            while (round < maxRounds && !readyToVote) {
                round++;
                addLog(`--- ç‹¼äººè®¨è®º ç¬¬ ${round} è½® ---`, "private");

                for (const p of wolves) {
                    const teammates = wolves.filter(x => x.id !== p.id).map(x => `${x.id + 1}å·`).join(', ');
                    const instruct = `é˜Ÿå‹æ˜¯: ${teammates || 'æ— '}ã€‚è¯·è®¨è®ºæˆ˜æœ¯ (discuss) æˆ–æè®®ç›´æ¥æŠ•ç¥¨ (vote_proposal)ã€‚`;

                    const raw = await streamLLM(p, 'wolf_discuss', instruct);
                    const j = processAndLogResponse(p.id, 'ç‹¼äºº', raw, false);

                    if (j && (j.action === 'vote_proposal' || j.action === 'vote')) {
                        readyToVote = true;
                        addLog(`${p.id + 1}å· æè®®å¼€å§‹æŠ•ç¥¨ã€‚`, "private");
                        break; // One wolf calls for vote, we move to vote
                    }
                }
            }

            // Wolf Voting Phase
            addLog("--- ç‹¼äººæŠ•ç¥¨é˜¶æ®µ ---", "private");
            let votes = {};
            for (const p of wolves) {
                const raw = await streamLLM(p, 'wolf_vote', "è¯·æŠ•ç¥¨å†³å®šè¢­å‡»è° (vote)ã€‚");
                const j = processAndLogResponse(p.id, 'ç‹¼äºº', raw, false);

                let t = -1;
                if (j && j.target !== undefined) t = parseInt(j.target);

                if (t !== -1) {
                    addLog(`${p.id + 1}å· æŠ•ç»™äº† ${t + 1}å·`, "private");
                    votes[t] = (votes[t] || 0) + 1;
                } else {
                    addLog(`${p.id + 1}å· å¼ƒç¥¨`, "private");
                }
            }

            // Tally Wolf Votes
            const s = Object.entries(votes).sort((a, b) => b[1] - a[1]);
            if (s.length > 0) {
                // Check for tie
                if (s.length > 1 && s[0][1] === s[1][1]) {
                    addLog("ğŸº ç‹¼äººæ„è§ä¸ç»Ÿä¸€ (å¹³ç¥¨)ï¼Œæ— äººè¢«åˆ€ã€‚", "private");
                    gameState.nightTarget = -1;
                } else {
                    gameState.nightTarget = parseInt(s[0][0]);
                    addLog(`ğŸº ç‹¼äººå†³å®šè¢­å‡» ${gameState.nightTarget + 1}å·`, "private");
                }
            } else {
                addLog("ğŸº ç‹¼äººæœªåšå‡ºæœ‰æ•ˆæŠ•ç¥¨ï¼Œæ— äººè¢«åˆ€ã€‚", "private");
                gameState.nightTarget = -1;
            }

            gameState.subPhase = 'guard';
        }

        async function runRole(r, k) {
            const p = players.find(x => x.role === r && x.alive);
            if (p) {
                const raw = await streamLLM(p, k, "è¯·è¡ŒåŠ¨ã€‚");
                const j = processAndLogResponse(p.id, r, raw, false);
                if (j && j.target !== undefined) {
                    if (r === 'é¢„è¨€å®¶') {
                        const t = parseInt(j.target);
                        const good = players[t].role !== 'ç‹¼äºº';
                        p.privateMem.push(`${t}å·æ˜¯${good ? 'å¥½äºº' : 'ç‹¼äºº'}`); // Add to Seer memory
                    }
                    if (r === 'å®ˆå«') gameState.guardLast = parseInt(j.target);
                }
            }
            gameState.subPhase = r === 'å®ˆå«' ? 'seer' : 'witch';
            updateHeader();
        }

        async function runWitch() {
            const p = players.find(x => x.role === 'å¥³å·«' && x.alive);
            gameState.witchAct = { save: false, harmTarget: -1 };
            if (p) {
                let i = `æ˜¨æ™š ${gameState.nightTarget + 1}å· è¢«åˆ€ã€‚`;
                if (gameState.nightTarget === gameState.guardLast) i = "æ˜¨æ™šå¹³å®‰ã€‚";
                const raw = await streamLLM(p, 'witch_night', `${i} è¯æ°´çŠ¶æ€: æ•‘=${gameState.settings.potion.save}, æ¯’=${gameState.settings.potion.harm}`);
                const j = processAndLogResponse(p.id, 'å¥³å·«', raw, false);
                if (j) {
                    if (j.type === 'save' && gameState.settings.potion.save) {
                        gameState.witchAct.save = true; gameState.settings.potion.save = false;
                    } else if ((j.type === 'potion_harm' || j.type === 'poison') && gameState.settings.potion.harm) {
                        gameState.witchAct.harmTarget = parseInt(j.target); gameState.settings.potion.harm = false;
                    }
                }
            }
            gameState.subPhase = 'morning';
            updateHeader();
        }

        async function resolveMorning() {
            addLog(`=== ç¬¬ ${gameState.dayCount} å¤© ===`, "sys");
            let dead = [], w = gameState.nightTarget;

            // Resolve Wolf Kill
            if (w !== -1) {
                if (w === gameState.guardLast) {
                    // Guarded
                } else if (gameState.witchAct.save) {
                    // Saved by Witch
                } else {
                    dead.push(w);
                }
            }

            // Resolve Witch Poison
            if (gameState.witchAct.harmTarget !== -1) {
                dead.push(gameState.witchAct.harmTarget);
            }

            dead = [...new Set(dead)]; // Unique

            // Announcement
            if (dead.length === 0) {
                addLog("æ˜¨æ™šæ˜¯å¹³å®‰å¤œã€‚", "public");
            } else if (dead.length === 1) {
                addLog(`æ˜¨æ™šæ˜¯ä¸€ä¸ªå¯æ€•çš„å¤œæ™šï¼Œ${dead[0] + 1}å· æ­»äº†ã€‚`, "public");
            } else {
                addLog(`æ˜¨æ™šæ˜¯ä¸€ä¸ªè¡€è…¥çš„å¤œæ™šï¼Œ${dead.map(x => x + 1).join(', ')}å· æ­»äº†ã€‚`, "public");
            }

            // Process Deaths & Last Words
            for (const pid of dead) {
                await handleDeath(pid);
            }

            gameState.subPhase = 'discuss';
            gameState.discussIdx = 0;
            updateHeader();
        }

        async function handleDeath(pid) {
            if (!players[pid].alive) return;
            kill(pid);

            // Last Words
            addLog(`ğŸ¤ ${pid + 1}å· å‘è¡¨é—è¨€...`, "public");
            const raw = await streamLLM(players[pid], 'day_discuss', "ä½ æ­»äº†ã€‚è¯·å‘è¡¨é—è¨€ (speech)ã€‚");
            processAndLogResponse(pid, players[pid].role, raw, true);

            // Hunter Skill
            if (players[pid].role === 'çŒäºº') {
                addLog(`ğŸ”« çŒäººæ­»äº¡ï¼Œå‘åŠ¨æŠ€èƒ½...`, "public");
                const hRaw = await streamLLM(players[pid], 'hunter_death', "ä½ æ­»äº†ã€‚å‘åŠ¨æŠ€èƒ½å¸¦èµ°ä¸€äºº (fire) æˆ–æ”¾å¼ƒ (pass)ã€‚");
                const j = processAndLogResponse(pid, 'çŒäºº', hRaw, true);

                if (j) {
                    if (j.action === 'fire' && j.target !== undefined) {
                        const target = parseInt(j.target); // already 0-based from processAndLogResponse
                        if (players[target] && players[target].alive) {
                            addLog(`ğŸ”« çŒäººå¼€æªå¸¦èµ°äº† ${target + 1}å·`, "public");
                            await handleDeath(target);
                        } else {
                            addLog(`ğŸ”« çŒäººè¯•å›¾å¸¦èµ° ${target + 1}å·ï¼Œä½†ç›®æ ‡æ— æ•ˆã€‚`, "public");
                        }
                    } else if (j.action === 'pass') {
                        addLog(`ğŸ”« çŒäººæ”¾å¼ƒå‘åŠ¨æŠ€èƒ½ã€‚`, "public");
                    } else {
                        addLog(`ğŸ”« çŒäººæœªèƒ½å‘åŠ¨æŠ€èƒ½ (æŒ‡ä»¤ä¸æ¸…)ã€‚`, "public");
                    }
                } else {
                    addLog(`ğŸ”« çŒäººæœªèƒ½å‘åŠ¨æŠ€èƒ½ (æ— å“åº”)ã€‚`, "public");
                }
            }
        }

        async function runDiscuss() {
            const a = players.filter(p => p.alive);
            if (gameState.discussIdx < a.length) {
                const p = a[gameState.discussIdx];
                const raw = await streamLLM(p, 'day_discuss', "è¯·ç®€çŸ­å‘è¨€ã€‚");
                processAndLogResponse(p.id, p.role, raw, true); // Public log
                gameState.discussIdx++;
            } else gameState.subPhase = 'vote';
            updateHeader();
        }

        async function runVote() {
            addLog("=== æŠ•ç¥¨é˜¶æ®µ ===", "sys");
            let v = {}; const a = players.filter(p => p.alive);
            for (const p of a) {
                const raw = await streamLLM(p, 'day_vote', "è¯·æŠ•ç¥¨ã€‚");
                const j = processAndLogResponse(p.id, p.role, raw, true);
                let t = -1;
                if (j && j.target !== undefined) t = parseInt(j.target);
                else { const o = a.filter(x => x.id !== p.id); if (o.length) t = o[Math.floor(Math.random() * o.length)].id; } // fallback
                addLog(`ğŸ—³ï¸ ${p.id + 1}å· æŠ•ç»™äº† ${t + 1}å·`, "public");
                v[t] = (v[t] || 0) + 1;
            }
            // Tally
            const s = Object.entries(v).sort((a, b) => b[1] - a[1]);
            if (s.length && s[0][1] > (s[1]?.[1] || 0)) {
                const o = parseInt(s[0][0]);
                addLog(`${o + 1}å· è¢«å…¬æŠ•å‡ºå±€ã€‚`, "public");
                await handleDeath(o);
            } else addLog("å¹³ç¥¨ï¼Œæ— äººå‡ºå±€ã€‚", "public");

            gameState.dayCount++;
            gameState.subPhase = 'wolf';
            gameState.phase = 'night';
            updateHeader();
        }

        /**
         * 7. HELPERS & UI UTILS
         */
        function kill(i) { if (players[i]) players[i].alive = false; }
        function gameOver(g) {
            gameState.status = 'gameover';
            const m = g ? "ğŸ† å¥½äººèƒœåˆ©" : "ğŸŒ™ ç‹¼äººèƒœåˆ©";
            addLog(m, "sys");
            document.getElementById('autoPlay').checked = false;
        }
        function clearLogs() { document.getElementById('gameLog').innerHTML = ''; }
        function escapeHtml(t) { if (!t) return ""; return t.replace(/&/g, "&").replace(/</g, "<").replace(/>/g, ">"); }
        function updateHeader() {
            const m = { 'wolf': 'ç‹¼äºº', 'seer': 'é¢„è¨€', 'witch': 'å¥³å·«', 'guard': 'å®ˆå«', 'discuss': 'å‘è¨€', 'vote': 'æŠ•ç¥¨' };
            document.getElementById('phaseDisplay').innerText = `Day ${gameState.dayCount} Â· ${m[gameState.subPhase] || ''}`;
        }
        function getAvatar(r) { return { 'ç‹¼äºº': 'ğŸº', 'æ‘æ°‘': 'ğŸ‘±', 'é¢„è¨€å®¶': 'ğŸ”®', 'å¥³å·«': 'ğŸ§ª', 'çŒäºº': 'ğŸ”«', 'å®ˆå«': 'ğŸ›¡ï¸' }[r] || 'â“'; }
        function toggleAuto() { const c = document.getElementById('autoPlay'); c.checked = !c.checked; if (c.checked) gameStep(); }

        // UI Builders
        function adjustPlayerCount(delta) {
            const current = appConfig.rolesSetup.length;
            const next = current + delta;
            if (next < 6 || next > 12) return;

            if (delta > 0) {
                appConfig.rolesSetup.push('æ‘æ°‘');
                appConfig.modelsSetup.push(availableModels[0] || 'gpt-3.5-turbo');
            } else {
                appConfig.rolesSetup.pop();
                appConfig.modelsSetup.pop();
            }
            initRoleConfig();
        }

        function initRoleConfig() {
            const c = document.getElementById('roleConfigList');
            c.innerHTML = '';
            const count = appConfig.rolesSetup.length;
            document.getElementById('playerCountDisplay').innerText = count;

            for (let i = 0; i < count; i++) {
                c.innerHTML += `
        <div class="flex gap-1 items-center bg-black/20 p-1 rounded border border-gray-700">
            <span class="text-xs text-gray-500 w-4 text-center">${i + 1}</span>
            <select id="role-${i}" onchange="appConfig.rolesSetup[${i}]=this.value; saveGlobalSettings();" class="bg-gray-900 text-[10px] rounded p-1 text-pink-400 border border-gray-600 w-16">
                ${['ç‹¼äºº', 'æ‘æ°‘', 'é¢„è¨€å®¶', 'å¥³å·«', 'çŒäºº', 'å®ˆå«'].map(x => `<option value="${x}"${appConfig.rolesSetup[i] === x ? 'selected' : ''}>${x}</option>`).join('')}
            </select>
            <select id="model-${i}" onchange="appConfig.modelsSetup[${i}]=this.value; saveGlobalSettings();" class="bg-gray-900 text-[10px] rounded p-1 text-blue-300 border border-gray-600 flex-1 w-24 truncate">
                ${availableModels.map(x => `<option value="${x}"${appConfig.modelsSetup[i] === x ? 'selected' : ''}>${x}</option>`).join('')}
            </select>
        </div>`;
            }
        }

        function updatePromptEditorList() {
            const s = document.getElementById('promptSelect'); s.innerHTML = '';
            Object.keys(appConfig.prompts).forEach(k => {
                s.innerHTML += `<option value="${k}">${k}</option>`;
            });
            loadPromptToEdit();
        }
        function loadPromptToEdit() {
            const k = document.getElementById('promptSelect').value;
            document.getElementById('promptText').value = appConfig.prompts[k];
        }
        function saveCurrentPrompt() {
            const k = document.getElementById('promptSelect').value;
            appConfig.prompts[k] = document.getElementById('promptText').value;
            // saveGlobalSettings(); // No longer auto-save to config, user must save preset
        }

        async function resetPrompts(updateUI = true) {
            try {
                const res = await fetch('/api/default_prompt');
                appConfig.prompts = await res.json();
                if (updateUI) {
                    updatePromptEditorList();
                    alert("å·²æ¢å¤é»˜è®¤ Prompt");
                }
            } catch (e) { console.error("Failed to load default prompt"); }
        }

        // Preset Management
        async function refreshPresetList() {
            const s = document.getElementById('presetSelect');
            s.innerHTML = '<option value="">-- é€‰æ‹©é¢„è®¾ --</option>';
            try {
                const res = await fetch('/api/presets');
                const files = await res.json();
                files.forEach(f => {
                    s.innerHTML += `<option value="${f}">${f}</option>`;
                });
            } catch (e) { }
        }

        async function loadPreset() {
            const name = document.getElementById('presetSelect').value;
            if (!name) return;
            try {
                const res = await fetch(`/api/presets/${name}`);
                appConfig.prompts = await res.json();
                updatePromptEditorList();
                alert(`å·²åŠ è½½é¢„è®¾: ${name}`);
            } catch (e) { alert("åŠ è½½å¤±è´¥"); }
        }

        async function savePreset() {
            const name = prompt("è¯·è¾“å…¥é¢„è®¾åç§° (ä¾‹å¦‚: my_custom_prompts):");
            if (!name) return;
            try {
                await fetch(`/api/presets/${name}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(appConfig.prompts)
                });
                refreshPresetList();
                alert("é¢„è®¾ä¿å­˜æˆåŠŸ!");
            } catch (e) { alert("ä¿å­˜å¤±è´¥"); }
        }

        async function deletePreset() {
            const name = document.getElementById('presetSelect').value;
            if (!name) return;
            if (!confirm(`ç¡®å®šåˆ é™¤é¢„è®¾ ${name}?`)) return;
            try {
                await fetch(`/api/presets/${name}`, { method: 'DELETE' });
                refreshPresetList();
            } catch (e) { alert("åˆ é™¤å¤±è´¥"); }
        }

        async function fetchModels() {
            try {
                const r = await fetch(`${appConfig.apiBase}/models`, { headers: { 'Authorization': `Bearer ${appConfig.apiKey}` } });
                const d = await r.json();
                availableModels = d.data.map(m => m.id);
                initRoleConfig();
                alert(`å·²åˆ·æ–° ${availableModels.length} ä¸ªæ¨¡å‹`);
            } catch (e) { alert("è·å–æ¨¡å‹å¤±è´¥"); }
        }

        function toggleSettings() { document.getElementById('settingsModal').classList.toggle('active'); }
        function renderGrid() {
            const g = document.getElementById('playersGrid'); g.innerHTML = '';
            players.forEach(p => {
                g.innerHTML += `
        <div id="card-${p.id}" class="role-card rounded p-2 flex flex-col items-center justify-center aspect-square relative bg-gray-800 ${!p.alive ? 'dead' : ''}">
            <div class="text-2xl mb-1">${p.alive ? p.avatar : 'ğŸ’€'}</div>
            <div class="text-[10px] ${p.role === 'ç‹¼äºº' ? 'text-red-400' : 'text-blue-300'}">${p.role}</div>
            <div class="absolute top-0 left-1 text-[9px] opacity-50">#${p.id + 1}</div>
        </div>`;
            });
        }

        // Start
        init();
    </script>
</body>

</html>