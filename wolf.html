<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI Áãº‰∫∫ÊùÄ - ÂÆåÊï¥ÂäüËÉΩÁâà</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --bg-color: #121212;
            --card-bg: #1e1e2e;
            --accent: #ff0055;
        }

        body {
            background-color: var(--bg-color);
            color: #e0e0e0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            padding-bottom: 120px;
        }

        /* Animations */
        @keyframes blink {
            50% {
                opacity: 0;
            }
        }

        .cursor::after {
            content: '‚ñã';
            animation: blink 1s infinite;
            color: var(--accent);
            margin-left: 2px;
        }

        .role-card {
            transition: all 0.3s;
            border: 1px solid #333;
            overflow: hidden;
        }

        .role-card.active {
            border-color: #4cc9f0;
            box-shadow: 0 0 15px rgba(76, 201, 240, 0.3);
            transform: scale(1.02);
            z-index: 10;
        }

        .role-card.dead {
            opacity: 0.4;
            filter: grayscale(100%);
            border-color: #333;
            background: #000;
        }

        .role-card.dead span {
            text-decoration: line-through;
        }

        /* Logs & Thoughts */
        .log-container {
            mask-image: linear-gradient(to bottom, transparent, black 2%);
            -webkit-mask-image: linear-gradient(to bottom, transparent, black 2%);
        }

        .log-entry {
            margin-bottom: 8px;
            padding: 8px 10px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.03);
            font-size: 0.85rem;
            line-height: 1.5;
            border-left: 3px solid #555;
        }

        .log-public {
            border-color: #f72585;
        }

        .log-private {
            border-color: #4cc9f0;
            background: rgba(76, 201, 240, 0.05);
        }

        .log-sys {
            border-color: #ffe600;
            color: #ffe600;
            font-weight: bold;
            text-align: center;
            background: rgba(255, 230, 0, 0.05);
        }

        /* Folded Thoughts */
        details.thought-bubble {
            margin-bottom: 4px;
            border: 1px dashed #444;
            border-radius: 4px;
            padding: 4px;
            background: #00000030;
        }

        details.thought-bubble summary {
            cursor: pointer;
            font-size: 0.7rem;
            color: #888;
            font-family: monospace;
            outline: none;
            user-select: none;
        }

        details.thought-bubble summary:hover {
            color: #aaa;
        }

        .thought-content {
            color: #aaa;
            font-size: 0.75rem;
            font-family: monospace;
            white-space: pre-wrap;
            margin-top: 4px;
            border-top: 1px solid #333;
            padding-top: 4px;
        }

        /* Modals */
        .modal {
            transition: opacity 0.2s;
            pointer-events: none;
            opacity: 0;
            z-index: 100;
        }

        .modal.active {
            pointer-events: auto;
            opacity: 1;
        }

        .btn-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            border-radius: 6px;
            background: #1f2937;
            color: white;
            border: 1px solid #374151;
        }

        .btn-icon:active {
            transform: scale(0.95);
        }

        /* Streaming Box */
        .think-text {
            color: #6b7280;
            font-style: italic;
        }

        .json-text {
            color: #4ade80;
        }
    </style>
</head>

<body class="text-sm antialiased select-none">

    <!-- Top Bar -->
    <div
        class="p-2 bg-gray-900/95 backdrop-blur fixed top-0 w-full z-50 border-b border-gray-800 flex justify-between items-center">
        <div class="flex items-center gap-2">
            <button onclick="resetGame()"
                class="btn-icon text-red-400 border-red-900 bg-red-900/10 h-8 w-16 text-xs font-bold gap-1">
                <span>üîÑ</span>ÈáçÂºÄ
            </button>
            <div class="flex flex-col">
                <h1 class="font-bold text-transparent bg-clip-text bg-gradient-to-r from-pink-500 to-purple-500">AI Áãº‰∫∫ÊùÄ
                    Pro+</h1>
                <span id="phaseDisplay" class="text-[9px] text-gray-400 font-mono leading-none">ÂáÜÂ§á‰∏≠</span>
            </div>
        </div>
        <div class="flex gap-2">
            <button onclick="undoStep()" id="btnUndo"
                class="btn-icon text-yellow-400 border-yellow-900 hover:bg-yellow-900/20">‚Ü©Ô∏è</button>
            <button onclick="openSaveModal()"
                class="btn-icon text-green-400 border-green-900 hover:bg-green-900/20">üíæ</button>
            <button onclick="openLoadModal()"
                class="btn-icon text-blue-400 border-blue-900 hover:bg-blue-900/20">üìÇ</button>
            <button onclick="toggleSettings()" class="btn-icon text-gray-300 hover:bg-gray-700">‚öôÔ∏è</button>
        </div>
    </div>

    <div class="pt-14 px-2">
        <!-- Action Bar -->
        <div class="flex gap-2 mb-3">
            <button id="btnStart" onclick="startGame()"
                class="flex-1 bg-green-700 hover:bg-green-600 py-3 rounded font-bold shadow text-white transition transform active:scale-95">ÂºÄÂßãÊñ∞Ê∏∏Êàè</button>
            <button id="btnStep" onclick="gameStep()" disabled
                class="flex-1 bg-indigo-600 hover:bg-indigo-500 py-3 rounded font-bold text-white disabled:opacity-20 disabled:cursor-not-allowed transition active:scale-95">‰∏ã‰∏ÄÊ≠•</button>
            <div class="flex items-center justify-center px-3 bg-gray-800 rounded text-xs border border-gray-700"
                onclick="toggleAuto()">
                <input type="checkbox" id="autoPlay" class="pointer-events-none w-4 h-4 accent-pink-500">
                <span class="ml-1 font-bold text-gray-300">Ëá™Âä®</span>
            </div>
        </div>

        <!-- Stream Output -->
        <div class="mb-4 relative group">
            <div class="flex justify-between text-[10px] text-gray-400 mb-1 pl-1 uppercase tracking-widest">
                <span>üëÅÔ∏è ÂÆûÊó∂ÊÄùÁª¥ÊµÅ (<span id="activePlayerName">...</span>)</span>
                <span id="retryIndicator" class="text-yellow-500 hidden blink">‚ö†Ô∏è ÁΩëÁªúÈáçËØï‰∏≠...</span>
            </div>
            <div id="streamingOutput"
                class="bg-[#0b0b12] border border-[#2d2d44] shadow-inner min-h-[100px] max-h-[180px] overflow-y-auto rounded-lg p-3 text-xs font-mono leading-relaxed">
                <span class="text-gray-600">Á≠âÂæÖÊ∏∏ÊàèÂºÄÂßã...</span>
            </div>
        </div>

        <!-- Players -->
        <div id="playersGrid" class="grid grid-cols-4 gap-2 mb-4 transition-all"></div>

        <!-- Logs -->
        <div class="flex justify-between items-end mb-2 px-1">
            <h3 class="font-bold text-gray-400 text-xs uppercase tracking-wider">‰∏äÂ∏ùÊó•Âøó</h3>
            <button onclick="clearLogs()" class="text-[10px] text-gray-600 hover:text-gray-300">Ê∏ÖÁ©∫</button>
        </div>
        <div id="gameLog"
            class="log-container flex flex-col-reverse h-[35vh] overflow-y-auto bg-gray-900/50 rounded-lg p-2 border border-gray-800/50">
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal fixed inset-0 flex items-center justify-center bg-black/80 backdrop-blur-sm">
        <div class="bg-gray-800 w-[90%] max-w-md h-[80vh] rounded-xl border border-gray-700 flex flex-col shadow-2xl">
            <div class="p-4 border-b border-gray-700 flex justify-between items-center bg-gray-900/50 rounded-t-xl">
                <h2 class="font-bold text-white">ËÆæÁΩÆ</h2>
                <button onclick="toggleSettings()" class="text-2xl text-gray-400">&times;</button>
            </div>
            <div class="flex-1 overflow-y-auto p-4 space-y-4">
                <!-- API -->
                <div class="space-y-2">
                    <label class="text-xs font-bold text-pink-400 uppercase">API Config</label>
                    <input type="text" id="apiBase" onchange="saveGlobalSettings()" placeholder="Base URL"
                        class="w-full bg-black/30 border border-gray-600 rounded p-2 text-xs text-white font-mono">
                    <input type="password" id="apiKey" onchange="saveGlobalSettings()" placeholder="API Key"
                        class="w-full bg-black/30 border border-gray-600 rounded p-2 text-xs text-white font-mono">
                    <button onclick="fetchModels()"
                        class="w-full bg-gray-700 text-xs py-2 rounded hover:bg-gray-600">Âà∑Êñ∞Ê®°ÂûãÂàóË°®</button>
                </div>
                <div class="border-t border-gray-700 my-2"></div>
                <!-- Prompt -->
                <div class="space-y-2">
                    <label class="text-xs font-bold text-blue-400 uppercase">Prompt Editor</label>

                    <!-- Preset Controls -->
                    <div class="flex gap-1 mb-2">
                        <select id="presetSelect"
                            class="bg-black/30 border border-gray-600 rounded p-1 text-xs text-gray-300 flex-1">
                            <option value="">-- ÈÄâÊã©È¢ÑËÆæ --</option>
                        </select>
                        <button onclick="loadPreset()"
                            class="btn-icon w-8 h-8 text-blue-400 border-blue-900">üìÇ</button>
                        <button onclick="savePreset()"
                            class="btn-icon w-8 h-8 text-green-400 border-green-900">üíæ</button>
                        <button onclick="deletePreset()"
                            class="btn-icon w-8 h-8 text-red-400 border-red-900">üóëÔ∏è</button>
                    </div>

                    <select id="promptSelect" onchange="loadPromptToEdit()"
                        class="w-full bg-black/30 border border-gray-600 rounded p-1 text-xs text-gray-300 mb-1"></select>
                    <textarea id="promptText" onchange="saveCurrentPrompt()"
                        class="w-full h-32 bg-black/30 border border-gray-600 rounded p-2 text-[10px] text-gray-300 font-mono leading-relaxed"></textarea>
                    <button onclick="resetPrompts()"
                        class="w-full border border-red-900 text-red-400 text-xs py-2 rounded hover:bg-red-900/20">ÈáçÁΩÆ‰∏∫ÈªòËÆ§
                        Prompt</button>
                </div>
                <div class="border-t border-gray-700 my-2"></div>
                <!-- Role Config -->
                <div class="flex justify-between items-center mb-2">
                    <label class="text-xs font-bold text-green-400 uppercase">Role Config (<span
                            id="playerCountDisplay">8</span>)</label>
                    <div class="flex gap-1">
                        <button onclick="adjustPlayerCount(-1)"
                            class="px-2 py-1 bg-gray-700 rounded text-xs hover:bg-gray-600">-</button>
                        <button onclick="adjustPlayerCount(1)"
                            class="px-2 py-1 bg-gray-700 rounded text-xs hover:bg-gray-600">+</button>
                    </div>
                </div>
                <div id="roleConfigList" class="space-y-1"></div>
            </div>
        </div>
    </div>

    <!-- Load/Save Modal -->
    <div id="loadModal" class="modal fixed inset-0 flex items-center justify-center bg-black/90 backdrop-blur z-[110]">
        <div class="bg-gray-900 w-[85%] max-w-sm rounded-xl border border-gray-700 p-4 shadow-2xl">
            <h2 class="font-bold text-white mb-4 flex justify-between">
                <span>Â≠òÊ°£ÂàóË°®</span>
                <button onclick="closeLoadModal()" class="text-gray-400">&times;</button>
            </h2>
            <button onclick="saveNewSlot()" id="btnSaveNew"
                class="w-full bg-green-800/50 border border-green-600 text-green-100 py-2 rounded mb-3 text-xs flex justify-center items-center gap-2">
                <span>‚ûï</span> Êñ∞Âª∫Â≠òÊ°£
            </button>
            <div id="saveSlotList" class="max-h-[60vh] overflow-y-auto space-y-2"></div>
        </div>
    </div>

    <script>
        /**
         * 1. CONFIG & CONSTANTS
         */
        const DEFAULT_ROLES = ['ÁôΩÁãºÁéã', 'Áãº‰∫∫', 'Áãº‰∫∫', 'Áãº‰∫∫', 'È¢ÑË®ÄÂÆ∂', 'Â•≥Â∑´', 'Áåé‰∫∫', 'ÂÆàÂç´', '‰∏òÊØîÁâπ', 'ÁôΩÁó¥', 'ÊùëÊ∞ë', 'ÊùëÊ∞ë', 'ÊùëÊ∞ë', 'ÊùëÊ∞ë', 'ÊùëÊ∞ë', 'ÊùëÊ∞ë'];
        let appConfig = {
            apiBase: "",
            apiKey: "",
            maxRetries: 3,
            prompts: {}, // Will load from server
            rolesSetup: [...DEFAULT_ROLES].slice(0, 8), // Default 8 players
            modelsSetup: Array(8).fill('gpt-3.5-turbo')
        };

        // History for Undo
        let historyStack = [];

        // Current State
        let gameState = {
            status: 'setup', dayCount: 0, phase: 'night', subPhase: 'init',
            logs: [], settings: { potion: { save: true, harm: true } },
            guardLast: -1, nightTarget: -1, witchAct: { save: false, harmTarget: -1 },
            cupidAct: null, sheriffId: -1
        };
        let players = [];
        let availableModels = ['gpt-3.5-turbo', 'gpt-4o-mini'];
        let isStreaming = false;
        let hasStorage = false;

        /**
         * 2. CORE INIT
         */
        async function init() {
            await loadGlobalSettings();
            await resetPrompts(false); // Load default prompts initially without saving
            initRoleConfig();
            updatePromptEditorList();
            refreshPresetList();
        }

        async function loadGlobalSettings() {
            try {
                const res = await fetch('/api/config');
                const data = await res.json();
                appConfig.apiBase = data.apiBase;
                appConfig.apiKey = data.apiKey;
                if (data.rolesSetup) appConfig.rolesSetup = data.rolesSetup;
                if (data.modelsSetup) appConfig.modelsSetup = data.modelsSetup;

                document.getElementById('apiBase').value = appConfig.apiBase;
                document.getElementById('apiKey').value = appConfig.apiKey;
            } catch (e) { console.error("Failed to load config", e); }
        }

        async function saveGlobalSettings() {
            appConfig.apiBase = document.getElementById('apiBase').value;
            appConfig.apiKey = document.getElementById('apiKey').value;
            try {
                await fetch('/api/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        apiBase: appConfig.apiBase,
                        apiKey: appConfig.apiKey,
                        rolesSetup: appConfig.rolesSetup,
                        modelsSetup: appConfig.modelsSetup
                    })
                });
            } catch (e) { console.error("Failed to save config", e); }
        }

        /**
         * 3. SAVE / LOAD / UNDO
         */
        function pushHistory() {
            // Save snapshot before change
            const snapshot = JSON.stringify({ gameState, players });
            historyStack.push(snapshot);
            if (historyStack.length > 20) historyStack.shift(); // Max 20 steps

            // Auto Save to latest
            performSave('autosave');
        }

        function undoStep() {
            if (historyStack.length === 0) return alert("Êó†Ê≥ïÂÜçÂõûÈÄÄ‰∫Ü");
            const prev = JSON.parse(historyStack.pop());
            gameState = prev.gameState;
            players = prev.players;

            // Refresh UI
            document.getElementById('gameLog').innerHTML = '';
            gameState.logs.forEach(l => addLogToDom(l));
            renderGrid();
            updateHeader();
            addLog("‚Ü©Ô∏è Êó∂ÂÖâÂÄíÊµÅÔºåÂõûÂà∞‰∫Ü‰∏ä‰∏ÄÊ≠•„ÄÇ", "sys");
        }

        function openSaveModal() {
            document.getElementById('loadModal').classList.add('active');
            document.getElementById('btnSaveNew').style.display = 'flex';
            renderSaveList(true); // Show save mode
        }

        function openLoadModal() {
            document.getElementById('loadModal').classList.add('active');
            document.getElementById('btnSaveNew').style.display = 'none';
            renderSaveList(false); // Show load mode
        }

        function closeLoadModal() {
            document.getElementById('loadModal').classList.remove('active');
        }

        async function renderSaveList(isSaveMode) {
            const list = document.getElementById('saveSlotList');
            list.innerHTML = '<div class="text-gray-500 text-center">Âä†ËΩΩ‰∏≠...</div>';

            try {
                const res = await fetch('/api/saves');
                const files = await res.json();
                list.innerHTML = '';

                files.forEach(f => {
                    createSlotUI(list, f, f, isSaveMode);
                });

                if (files.length === 0) {
                    list.innerHTML = '<div class="text-gray-500 text-center">ÊöÇÊó†Â≠òÊ°£</div>';
                }
            } catch (e) {
                list.innerHTML = '<div class="text-red-500 text-center">Âä†ËΩΩÂ§±Ë¥•</div>';
            }
        }

        function createSlotUI(container, filename, label, isSaveMode) {
            const div = document.createElement('div');
            div.className = "bg-gray-800 p-2 rounded border border-gray-700 flex justify-between items-center";

            const btn = document.createElement('button');
            btn.className = "text-xs text-left flex-1 text-gray-300 hover:text-white";
            btn.innerText = label;

            if (isSaveMode) {
                btn.onclick = () => { if (confirm("Ë¶ÜÁõñÊ≠§Â≠òÊ°£?")) performSave(filename); };
            } else {
                btn.onclick = () => performLoad(filename);
            }

            const del = document.createElement('button');
            del.className = "ml-2 text-red-500 px-2 hover:text-red-400 text-xs";
            del.innerText = "üóëÔ∏è";
            del.onclick = async (e) => {
                e.stopPropagation();
                if (confirm("Á°ÆÂÆöÂà†Èô§?")) {
                    await fetch(`/api/saves/${filename}`, { method: 'DELETE' });
                    renderSaveList(isSaveMode);
                }
            };

            div.appendChild(btn);
            div.appendChild(del);
            container.appendChild(div);
        }

        function saveNewSlot() {
            const name = prompt("ËØ∑ËæìÂÖ•Â≠òÊ°£ÂêçÁß∞:", `save_${Date.now()}`);
            if (name) performSave(name);
        }

        async function performSave(filename) {
            const data = { gameState, players };
            try {
                await fetch(`/api/saves/${filename}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                closeLoadModal();
                // alert("Â≠òÊ°£ÊàêÂäü!"); // Disable alert for autosave
                if (filename !== 'autosave') alert("Â≠òÊ°£ÊàêÂäü!");
            } catch (e) { if (filename !== 'autosave') alert("Â≠òÊ°£Â§±Ë¥•"); }
        }

        async function performLoad(filename) {
            try {
                const res = await fetch(`/api/saves/${filename}`);
                if (!res.ok) throw new Error("Load failed");
                const d = await res.json();

                historyStack = [];
                gameState = d.gameState;
                players = d.players;

                document.getElementById('gameLog').innerHTML = '';
                gameState.logs.forEach(l => addLogToDom(l));
                renderGrid();
                updateHeader();
                document.getElementById('btnStart').classList.add('hidden');
                document.getElementById('btnStep').disabled = false;

                closeLoadModal();
                addLog(`üìÇ ËØªÊ°£ÊàêÂäü: ${filename}`, "sys");
            } catch (e) { alert("ËØªÊ°£Â§±Ë¥•"); }
        }

        function resetGame() {
            document.getElementById('autoPlay').checked = false;
            isStreaming = false;

            gameState = {
                status: 'setup', dayCount: 0, phase: 'night', subPhase: 'init',
                logs: [], settings: { potion: { save: true, harm: true } },
                guardLast: -1, nightTarget: -1, witchAct: { save: false, harmTarget: -1 },
                cupidAct: null, sheriffId: -1
            };
            players = [];
            historyStack = [];

            document.getElementById('gameLog').innerHTML = '';
            document.getElementById('playersGrid').innerHTML = '';
            document.getElementById('phaseDisplay').innerText = 'ÂáÜÂ§á‰∏≠';
            document.getElementById('activePlayerName').innerText = '...';
            document.getElementById('streamingOutput').innerHTML = '<span class="text-gray-600">Á≠âÂæÖÊ∏∏ÊàèÂºÄÂßã...</span>';

            document.getElementById('btnStart').classList.remove('hidden');
            document.getElementById('btnStep').disabled = true;

            addLog("=== Ê∏∏ÊàèÂ∑≤ÈáçÁΩÆ ===", "sys");
        }

        /**
         * 4. GAME ENGINE
         */
        function startGame() {
            players = [];
            gameState = {
                status: 'playing', dayCount: 1, phase: 'night', subPhase: 'cupid', // Start with Cupid
                logs: [], settings: { potion: { save: true, harm: true } },
                guardLast: -1, nightTarget: -1, witchAct: { save: false, harmTarget: -1 },
                cupidAct: null, sheriffId: -1
            };
            historyStack = [];
            document.getElementById('gameLog').innerHTML = '';

            const count = appConfig.rolesSetup.length;
            const w = [];

            // 1. Collect Config
            for (let i = 0; i < count; i++) {
                const r = document.getElementById(`role-${i}`).value;
                if (r === 'Áãº‰∫∫' || r === 'ÁôΩÁãºÁéã') w.push(i);
                players.push({
                    id: i, role: r, model: document.getElementById(`model-${i}`).value,
                    alive: true, privateMem: [], avatar: getAvatar(r),
                    isSheriff: false, isCouple: false, coupleId: -1, isIdiotRevealed: false, canVote: true, deathReason: null
                });
            }

            // 2. Validation
            const good = players.filter(p => p.role !== 'Áãº‰∫∫' && p.role !== 'ÁôΩÁãºÁéã');
            if (w.length < 1 || good.length < 1) {
                alert("ÈÖçÁΩÆÈîôËØØÔºöËá≥Â∞ëÈúÄË¶Å 1 ‰∏™Áãº‰∫∫Âíå 1 ‰∏™Â•Ω‰∫∫ÔºÅ");
                return;
            }

            // 3. Init Memory
            players.forEach(p => {
                let m = `‰Ω†ÁöÑÁºñÂè∑ÊòØ ${p.id + 1}Âè∑„ÄÇË∫´‰ªΩ: ${p.role}„ÄÇ`;
                if (p.role === 'Áãº‰∫∫' || p.role === 'ÁôΩÁãºÁéã') {
                    const mates = w.filter(x => x !== p.id).map(x => `${x + 1}Âè∑`).join(', ');
                    m += ` ÈòüÂèã: ${mates || 'Êó†'}„ÄÇ`;
                }
                if (p.role === 'ÁôΩÁãºÁéã') m += " ‰Ω†ÊòØÁôΩÁãºÁéãÔºåÁôΩÂ§©ÂèØ‰ª•Ëá™ÁàÜÂ∏¶‰∫∫„ÄÇ";
                if (p.role === '‰∏òÊØîÁâπ') m += " ‰Ω†ÊòØ‰∏òÊØîÁâπÔºåÈ¶ñÂ§úÂèØ‰ª•ËøûÊé•‰∏§ÂêçÊÉÖ‰æ£„ÄÇ";
                if (p.role === 'ÁôΩÁó¥') m += " ‰Ω†ÊòØÁôΩÁó¥ÔºåË¢´ÂÖ¨ÊäïÂá∫Â±ÄÂèØ‰ª•ÁøªÁâåÂÖçÊ≠ª„ÄÇ";
                p.privateMem.push(m);
            });

            renderGrid();
            addLog("=== Ê∏∏ÊàèÂºÄÂßã ===", "sys");
            document.getElementById('btnStart').classList.add('hidden');
            document.getElementById('btnStep').disabled = false;
            updateHeader();
            pushHistory();
            if (document.getElementById('autoPlay').checked) gameStep();
        }

        async function gameStep() {
            if (gameState.status === 'gameover' || isStreaming) return;

            pushHistory(); // Snapshot state before moving

            try {
                await processPhase();
            } catch (e) {
                console.error(e);
                addLog(`‚ùå ÈîôËØØ: ${e.message}`, "sys");
                isStreaming = false;
                document.getElementById('autoPlay').checked = false;
            }
            renderGrid();

            if (gameState.status !== 'gameover' && document.getElementById('autoPlay').checked) {
                setTimeout(gameStep, 1500);
            }
        }

        async function processPhase() {
            const wolves = players.filter(p => p.alive && (p.role === 'Áãº‰∫∫' || p.role === 'ÁôΩÁãºÁéã'));
            const gods = players.filter(p => p.alive && ['È¢ÑË®ÄÂÆ∂', 'Â•≥Â∑´', 'Áåé‰∫∫', 'ÂÆàÂç´', '‰∏òÊØîÁâπ', 'ÁôΩÁó¥'].includes(p.role));
            const villagers = players.filter(p => p.alive && p.role === 'ÊùëÊ∞ë');

            // Victory Condition: Slaughter the Side (Â±†Ëæπ)
            if (wolves.length === 0) return gameOver(true); // Good wins
            if (gods.length === 0 || villagers.length === 0) return gameOver(false); // Wolf wins

            switch (gameState.subPhase) {
                case 'cupid': await runCupid(); break;
                case 'wolf': await runWolf(); break;
                case 'seer': await runRole('È¢ÑË®ÄÂÆ∂', 'seer_night'); break;
                case 'guard': await runRole('ÂÆàÂç´', 'guard_night'); break;
                case 'witch': await runWitch(); break;
                case 'morning': resolveMorning(); break;
                case 'election': await runElection(); break;
                case 'discuss': await runDiscuss(); break;
                case 'vote': await runVote(); break;
                case 'review': await runReview(); break;
            }
        }

        /**
         * 5. STREAMING & PARSING (CoT Logic)
         */
        async function streamLLM(player, key, instruct) {
            // Allow dead players to speak during review
            if (!player.alive && gameState.subPhase !== 'review') return null;

            document.getElementById('activePlayerName').innerText = `${player.id + 1}Âè∑`;
            const card = document.getElementById(`card-${player.id}`);
            if (card) card.classList.add('active');
            isStreaming = true;

            let final = "";
            const outEl = document.getElementById('streamingOutput');

            // Retry Logic
            let attempts = 0;
            const maxRetries = appConfig.maxRetries || 3;

            while (attempts < maxRetries) {
                attempts++;
                final = "";
                outEl.innerHTML = `<span class="text-gray-500">Â∞ùËØï ${attempts}/${maxRetries}...</span>`;

                // Convert internal 0-based IDs to 1-based for Prompt
                const aliveList = players.filter(p => p.alive).map(p => `${p.id + 1}Âè∑`).join(', ');

                // Filter logs: Only show public logs to everyone.
                const publicLogs = gameState.logs
                    .filter(l => l.type === 'public' || l.type === 'sys')
                    .map(l => l.content)
                    .join('\n');

                const context = `
[Public History]
${publicLogs}
[Private Memory]
${player.privateMem.join('\n')}
[Alive Players]
${aliveList}
[System]
Current Phase: ${gameState.subPhase}
Instruction: ${instruct}`;

                const sys = appConfig.prompts.common + "\n" + appConfig.prompts[key];

                try {
                    const res = await fetch(`${appConfig.apiBase}/chat/completions`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${appConfig.apiKey}` },
                        body: JSON.stringify({
                            model: player.model,
                            messages: [{ role: 'system', content: sys }, { role: 'user', content: context }],
                            temperature: 0.7,
                            max_tokens: 4096, // HUGE TOKEN LIMIT
                            stream: true
                        })
                    });

                    if (!res.ok) throw new Error(`API Error ${res.status}`);

                    const reader = res.body.getReader();
                    const decoder = new TextDecoder();

                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n');
                        for (const line of lines) {
                            if (line.startsWith('data: ') && line !== 'data: [DONE]') {
                                try {
                                    const txt = JSON.parse(line.slice(6)).choices[0].delta.content || "";
                                    final += txt;

                                    // Visual Formatting
                                    let displayHtml = escapeHtml(final);
                                    displayHtml = displayHtml.replace(/<think>/g, '<span class="think-text"><think>');
                                    displayHtml = displayHtml.replace(/<\/think>/g, '</think></span>');
                                    displayHtml = displayHtml.replace(/"thought":/g, '<span class="think-text">"thought":</span>');
                                    displayHtml = displayHtml.replace(/"action":/g, '<span class="json-text">"action":</span>');

                                    outEl.innerHTML = displayHtml + '<span class="cursor"></span>';
                                    outEl.scrollTop = outEl.scrollHeight;
                                } catch (e) { }
                            }
                        }
                    }

                    // Check if output is valid JSON
                    if (parseMixedOutput(final)) {
                        break; // Success!
                    } else {
                        throw new Error("Invalid JSON output");
                    }

                } catch (e) {
                    console.error(`Attempt ${attempts} failed:`, e);
                    document.getElementById('retryIndicator').classList.remove('hidden');
                    await new Promise(r => setTimeout(r, 1000)); // Wait 1s before retry
                }
            }

            document.getElementById('retryIndicator').classList.add('hidden');
            isStreaming = false;
            if (card) card.classList.remove('active');

            // Debug Log
            try {
                fetch('/api/debug_log', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        timestamp: new Date().toISOString(),
                        player: player.id + 1,
                        role: player.role,
                        prompt: { system: sys, user: context },
                        response: final
                    })
                });
            } catch (e) { }

            player.privateMem.push(`(Self): ${extractActionSummary(final)}`);
            return final;
        }

        function extractActionSummary(text) {
            // Helper to store short memory not the huge thought chain
            const json = parseMixedOutput(text);
            if (!json) return "Acted.";
            if (json.speech) return `Speech: ${json.speech.substring(0, 20)}...`;
            if (json.action) return `Action: ${json.action} -> ${json.target}`;
            return "Acted.";
        }

        /**
         * SMART PARSER: Handles Thought Fields & Tags
         */
        function parseMixedOutput(text) {
            if (typeof text !== 'string') return null;
            try {
                // 0. Try to extract from markdown code blocks (find ALL, use LAST valid)
                const codeBlockRegex = /```(?:json)?\s*([\s\S]*?)\s*```/g;
                const matches = [...text.matchAll(codeBlockRegex)];

                if (matches.length > 0) {
                    // Iterate backwards to find the last valid JSON
                    for (let i = matches.length - 1; i >= 0; i--) {
                        try {
                            return JSON.parse(matches[i][1]);
                        } catch (e) {
                            // Continue to previous match
                        }
                    }
                }

                // 1. Fallback: Try to find last JSON object in raw text
                const firstBrace = text.indexOf('{');
                const lastBrace = text.lastIndexOf('}');
                if (firstBrace !== -1 && lastBrace !== -1) {
                    // Try to parse the whole block first
                    const potentialJson = text.substring(firstBrace, lastBrace + 1);
                    try {
                        return JSON.parse(potentialJson);
                    } catch (e) {
                        // If that fails, maybe there are multiple JSONs concatenated?
                        // Let's try to find the *last* valid JSON object by scanning backwards
                        // This is complex, so for now we stick to the simple extraction.
                        // A more robust way would be to use a stack-based parser, but let's hope the code block fix covers 99% cases.
                    }
                }
                return null;
            } catch (e) { return null; }
        }

        function addLog(content, type, thoughtContent = null, role = null) {
            const entry = { content, type, thought: thoughtContent, role };
            gameState.logs.push(entry);
            addLogToDom(entry);
        }

        function addLogToDom(entry) {
            const div = document.createElement('div');
            div.className = `log-entry log-${entry.type}`;

            // If there is thought, make a fold
            if (entry.thought) {
                const details = document.createElement('details');
                details.className = 'thought-bubble';
                details.innerHTML = `
            <summary>üí≠ ÊÄùËÄÉËøáÁ®ã (ÁÇπÂáªÂ±ïÂºÄ)</summary>
            <div class="thought-content">${escapeHtml(entry.thought)}</div>
        `;
                div.appendChild(details);
            }

            const text = document.createElement('div');
            // For God View (UI), show role if available
            let displayContent = entry.content;
            if (entry.role && entry.type === 'public') {
                displayContent = displayContent.replace(/^(\d+Âè∑)/, `$1(${entry.role})`);
            }
            text.innerText = displayContent;
            div.appendChild(text);

            const cont = document.getElementById('gameLog');
            cont.prepend(div);
        }

        function processAndLogResponse(playerId, roleName, rawText, isPublic) {
            let json = parseMixedOutput(rawText);
            let thought = null;

            // Extract thought from <think> tags if models use them
            const thinkMatch = rawText.match(/<think>([\s\S]*?)<\/think>/);
            if (thinkMatch) thought = thinkMatch[1].trim();

            if (json) {
                // Extract thought from JSON field
                if (json.thought || json.reasoning) {
                    thought = json.thought || json.reasoning;
                }

                // Construct Clean Log
                let msg = "";
                if (json.speech) userMsg = json.speech;
                else if (json.action) {
                    if (json.target !== undefined) userMsg = `ÊâßË°å‰∫Ü ${json.action} -> ${json.target}`;
                    else userMsg = `ÊâßË°å‰∫Ü ${json.action}`;
                }
                else userMsg = "ËøõË°å‰∫ÜÊÄùËÄÉ (Êó†ÂÖ∑‰ΩìË°åÂä®)";

                // Convert target from 1-based to 0-based if present
                if (json.target !== undefined && typeof json.target === 'number') {
                    json.target = json.target - 1;
                }

                if (isPublic) {
                    // IMPORTANT: Do NOT include roleName in the content string stored in logs
                    // It will be added dynamically for UI display, but kept hidden for AI context
                    msg = `${playerId + 1}Âè∑: ${userMsg}`;
                } else {
                    msg = `${roleName}Ë°åÂä®: ${userMsg}`;
                }

                addLog(msg, isPublic ? "public" : "private", thought, isPublic ? roleName : null);
                return json; // Return parsed action for logic
            }

            // Fallback if no JSON found
            addLog(`${playerId + 1}Âè∑ (ÂºÇÂ∏∏ËæìÂá∫): Êú™Ê£ÄÊµãÂà∞ÊúâÊïàÊåá‰ª§`, "private", rawText);
            return null;
        }

        /**
         * 6. ROLE LOGIC WRAPPERS
         */
        async function runCupid() {
            addLog("=== ‰∏òÊØîÁâπËØ∑ÁùÅÁúº ===", "sys");
            const cupid = players.find(p => p.role === '‰∏òÊØîÁâπ' && p.alive);
            if (cupid) {
                const raw = await streamLLM(cupid, 'cupid_night', "ËØ∑ÈÄâÊã©‰∏§ÂêçÁé©ÂÆ∂Êàê‰∏∫ÊÉÖ‰æ£ (link)„ÄÇ");
                const j = processAndLogResponse(cupid.id, '‰∏òÊØîÁâπ', raw, false);
                if (j && j.action === 'link' && j.target1 !== undefined && j.target2 !== undefined) {
                    const t1 = parseInt(j.target1) - 1;
                    const t2 = parseInt(j.target2) - 1;
                    if (players[t1] && players[t2]) {
                        players[t1].isCouple = true; players[t1].coupleId = t2;
                        players[t2].isCouple = true; players[t2].coupleId = t1;
                        players[t1].privateMem.push(`‰Ω†Ë¢´‰∏òÊØîÁâπËøûÊàê‰∫ÜÊÉÖ‰æ£„ÄÇ‰Ω†ÁöÑ‰º¥‰æ£ÊòØ ${t2 + 1}Âè∑„ÄÇ`);
                        players[t2].privateMem.push(`‰Ω†Ë¢´‰∏òÊØîÁâπËøûÊàê‰∫ÜÊÉÖ‰æ£„ÄÇ‰Ω†ÁöÑ‰º¥‰æ£ÊòØ ${t1 + 1}Âè∑„ÄÇ`);
                        gameState.cupidAct = { t1, t2 };
                    }
                }
            }
            gameState.subPhase = 'wolf';
            updateHeader();
        }

        async function runWolf() {
            addLog("=== Â§©ÈªëËØ∑Èó≠Áúº ===", "sys");
            gameState.nightTarget = -1;
            const wolves = players.filter(p => (p.role === 'Áãº‰∫∫' || p.role === 'ÁôΩÁãºÁéã') && p.alive);

            if (wolves.length === 0) {
                gameState.subPhase = 'guard';
                return;
            }

            // Wolf Discussion Phase
            let round = 0;
            let readyToVote = false;
            const maxRounds = 3;

            addLog(`üê∫ Áãº‰∫∫ÂºÄÂßãË°åÂä® (Â≠òÊ¥ª: ${wolves.map(p => p.id + 1).join(',')})`, "private");

            while (round < maxRounds && !readyToVote) {
                round++;
                addLog(`--- Áãº‰∫∫ËÆ®ËÆ∫ Á¨¨ ${round} ËΩÆ ---`, "private");

                for (const p of wolves) {
                    const teammates = wolves.filter(x => x.id !== p.id).map(x => `${x.id + 1}Âè∑`).join(', ');
                    const instruct = `ÈòüÂèãÊòØ: ${teammates || 'Êó†'}„ÄÇËØ∑ËÆ®ËÆ∫ÊàòÊúØ (discuss) ÊàñÊèêËÆÆÁõ¥Êé•ÊäïÁ•® (vote_proposal)„ÄÇ`;

                    const raw = await streamLLM(p, 'wolf_discuss', instruct);
                    const j = processAndLogResponse(p.id, 'Áãº‰∫∫', raw, false);

                    // Share discussion with other wolves
                    if (j && j.speech) {
                        const chatMsg = `(ÈòüÂèã) ${p.id + 1}Âè∑: ${j.speech}`;
                        wolves.forEach(w => {
                            if (w.id !== p.id) w.privateMem.push(chatMsg);
                        });
                    }

                    if (j && (j.action === 'vote_proposal' || j.action === 'vote')) {
                        readyToVote = true;
                        addLog(`${p.id + 1}Âè∑ ÊèêËÆÆÂºÄÂßãÊäïÁ•®„ÄÇ`, "private");
                        break; // One wolf calls for vote, we move to vote
                    }
                }
            }

            // Wolf Voting Phase
            addLog("--- Áãº‰∫∫ÊäïÁ•®Èò∂ÊÆµ ---", "private");
            let votes = {};
            for (const p of wolves) {
                const raw = await streamLLM(p, 'wolf_vote', "ËØ∑ÊäïÁ•®ÂÜ≥ÂÆöË¢≠ÂáªË∞Å (vote)„ÄÇ");
                const j = processAndLogResponse(p.id, 'Áãº‰∫∫', raw, false);

                let t = -1;
                if (j && j.target !== undefined) t = parseInt(j.target);

                if (t !== -1) {
                    addLog(`${p.id + 1}Âè∑ ÊäïÁªô‰∫Ü ${t + 1}Âè∑`, "private");
                    votes[t] = (votes[t] || 0) + 1;
                } else {
                    addLog(`${p.id + 1}Âè∑ ÂºÉÁ•®`, "private");
                }
            }

            // Tally Wolf Votes
            const s = Object.entries(votes).sort((a, b) => b[1] - a[1]);
            if (s.length > 0) {
                // Check for tie
                if (s.length > 1 && s[0][1] === s[1][1]) {
                    addLog("üê∫ Áãº‰∫∫ÊÑèËßÅ‰∏çÁªü‰∏Ä (Âπ≥Á•®)ÔºåÊó†‰∫∫Ë¢´ÂàÄ„ÄÇ", "private");
                    gameState.nightTarget = -1;
                } else {
                    gameState.nightTarget = parseInt(s[0][0]);
                    addLog(`üê∫ Áãº‰∫∫ÂÜ≥ÂÆöË¢≠Âáª ${gameState.nightTarget + 1}Âè∑`, "private");
                }
            } else {
                addLog("üê∫ Áãº‰∫∫Êú™ÂÅöÂá∫ÊúâÊïàÊäïÁ•®ÔºåÊó†‰∫∫Ë¢´ÂàÄ„ÄÇ", "private");
                gameState.nightTarget = -1;
            }

            gameState.subPhase = 'guard';
        }

        async function runRole(r, k) {
            const p = players.find(x => x.role === r && x.alive);
            if (p) {
                const raw = await streamLLM(p, k, "ËØ∑Ë°åÂä®„ÄÇ");
                const j = processAndLogResponse(p.id, r, raw, false);
                if (j && j.target !== undefined) {
                    if (r === 'È¢ÑË®ÄÂÆ∂') {
                        const t = parseInt(j.target);
                        const good = players[t].role !== 'Áãº‰∫∫' && players[t].role !== 'ÁôΩÁãºÁéã';
                        p.privateMem.push(`${t}Âè∑ÊòØ${good ? 'Â•Ω‰∫∫' : 'Áãº‰∫∫'}`); // Add to Seer memory
                    }
                    if (r === 'ÂÆàÂç´') gameState.guardLast = parseInt(j.target);
                }
            }
            gameState.subPhase = r === 'ÂÆàÂç´' ? 'seer' : 'witch';
            updateHeader();
        }

        async function runWitch() {
            const p = players.find(x => x.role === 'Â•≥Â∑´' && x.alive);
            gameState.witchAct = { save: false, harmTarget: -1 };
            if (p) {
                let i = `Êò®Êôö ${gameState.nightTarget + 1}Âè∑ Ë¢´ÂàÄ„ÄÇ`;
                if (gameState.nightTarget === gameState.guardLast) i = "Êò®ÊôöÂπ≥ÂÆâ„ÄÇ";
                const raw = await streamLLM(p, 'witch_night', `${i} ËçØÊ∞¥Áä∂ÊÄÅ: Êïë=${gameState.settings.potion.save}, ÊØí=${gameState.settings.potion.harm}`);
                const j = processAndLogResponse(p.id, 'Â•≥Â∑´', raw, false);
                if (j) {
                    if (j.type === 'save' && gameState.settings.potion.save) {
                        gameState.witchAct.save = true; gameState.settings.potion.save = false;
                    } else if ((j.type === 'potion_harm' || j.type === 'poison') && gameState.settings.potion.harm) {
                        gameState.witchAct.harmTarget = parseInt(j.target); gameState.settings.potion.harm = false;
                    }
                }
            }
            gameState.subPhase = 'morning';
            updateHeader();
        }

        async function resolveMorning() {
            addLog(`=== Á¨¨ ${gameState.dayCount} Â§© ===`, "sys");
            let dead = [], w = gameState.nightTarget;

            // Resolve Wolf Kill
            if (w !== -1) {
                if (w === gameState.guardLast) {
                    // Guarded
                } else if (gameState.witchAct.save) {
                    // Saved by Witch
                } else {
                    dead.push(w);
                    if (players[w]) players[w].deathReason = 'wolf';
                }
            }

            // Resolve Witch Poison
            if (gameState.witchAct.harmTarget !== -1) {
                dead.push(gameState.witchAct.harmTarget);
                if (players[gameState.witchAct.harmTarget]) players[gameState.witchAct.harmTarget].deathReason = 'poison';
            }

            dead = [...new Set(dead)]; // Unique

            // Announcement
            if (dead.length === 0) {
                addLog("Êò®ÊôöÊòØÂπ≥ÂÆâÂ§ú„ÄÇ", "public");
            } else if (dead.length === 1) {
                addLog(`Êò®ÊôöÊòØ‰∏Ä‰∏™ÂèØÊÄïÁöÑÂ§úÊôöÔºå${dead[0] + 1}Âè∑ Ê≠ª‰∫Ü„ÄÇ`, "public");
            } else {
                addLog(`Êò®ÊôöÊòØ‰∏Ä‰∏™Ë°ÄËÖ•ÁöÑÂ§úÊôöÔºå${dead.map(x => x + 1).join(', ')}Âè∑ Ê≠ª‰∫Ü„ÄÇ`, "public");
            }

            // Process Deaths & Last Words
            for (const pid of dead) {
                await handleDeath(pid);
            }

            if (gameState.dayCount === 1) gameState.subPhase = 'election';
            else gameState.subPhase = 'discuss';

            gameState.discussIdx = 0;
            updateHeader();
        }

        async function handleDeath(pid) {
            if (!players[pid].alive) return;

            // Last Words (Before killing, so streamLLM works)
            addLog(`üé§ ${pid + 1}Âè∑ ÂèëË°®ÈÅóË®Ä...`, "public");
            const raw = await streamLLM(players[pid], 'day_discuss', "‰Ω†Ê≠ª‰∫Ü„ÄÇËØ∑ÂèëË°®ÈÅóË®Ä (speech)„ÄÇ");
            processAndLogResponse(pid, players[pid].role, raw, true);

            kill(pid);

            // Hunter Skill
            if (players[pid].role === 'Áåé‰∫∫') {
                if (players[pid].deathReason === 'poison') {
                    addLog(`üî´ Áåé‰∫∫Ë¢´ÊØíÊùÄÔºåÊó†Ê≥ïÂèëÂä®ÊäÄËÉΩ„ÄÇ`, "public");
                } else {
                    addLog(`üî´ Áåé‰∫∫Ê≠ª‰∫°ÔºåÂèëÂä®ÊäÄËÉΩ...`, "public");
                    const hRaw = await streamLLM(players[pid], 'hunter_death', "‰Ω†Ê≠ª‰∫Ü„ÄÇÂèëÂä®ÊäÄËÉΩÂ∏¶Ëµ∞‰∏Ä‰∫∫ (fire) ÊàñÊîæÂºÉ (pass)„ÄÇ");
                    const j = processAndLogResponse(pid, 'Áåé‰∫∫', hRaw, true);

                    if (j) {
                        if (j.action === 'fire' && j.target !== undefined) {
                            const target = parseInt(j.target) - 1;
                            if (players[target] && players[target].alive) {
                                addLog(`üî´ Áåé‰∫∫ÂºÄÊû™Â∏¶Ëµ∞‰∫Ü ${target + 1}Âè∑`, "public");
                                await handleDeath(target);
                            } else {
                                addLog(`üî´ Áåé‰∫∫ËØïÂõæÂ∏¶Ëµ∞ ${target + 1}Âè∑Ôºå‰ΩÜÁõÆÊ†áÊó†Êïà„ÄÇ`, "public");
                            }
                        } else if (j.action === 'pass') {
                            addLog(`üî´ Áåé‰∫∫ÊîæÂºÉÂèëÂä®ÊäÄËÉΩ„ÄÇ`, "public");
                        } else {
                            addLog(`üî´ Áåé‰∫∫Êú™ËÉΩÂèëÂä®ÊäÄËÉΩ (Êåá‰ª§‰∏çÊ∏Ö)„ÄÇ`, "public");
                        }
                    } else {
                        addLog(`üî´ Áåé‰∫∫Êú™ËÉΩÂèëÂä®ÊäÄËÉΩ (Êó†ÂìçÂ∫î)„ÄÇ`, "public");
                    }
                }
            }
        }

        async function runElection() {
            addLog("=== Ë≠¶ÈïøÁ´ûÈÄâ ===", "sys");
            const candidates = [];
            // 1. Run for Sheriff
            for (const p of players.filter(x => x.alive)) {
                const raw = await streamLLM(p, 'sheriff_election', "ÊòØÂê¶Á´ûÈÄâË≠¶ÈïøÔºü(run/pass)");
                const j = processAndLogResponse(p.id, p.role, raw, true);
                if (j && j.action === 'run') candidates.push(p.id);
            }

            if (candidates.length === 0) {
                addLog("Êó†‰∫∫Á´ûÈÄâË≠¶Èïø„ÄÇ", "public");
            } else if (candidates.length === 1) {
                gameState.sheriffId = candidates[0];
                players[candidates[0]].isSheriff = true;
                addLog(`${candidates[0] + 1}Âè∑ Ëá™Âä®ÂΩìÈÄâË≠¶ÈïøÔºÅ`, "public");
            } else {
                // 2. Vote
                addLog(`ÂÄôÈÄâ‰∫∫: ${candidates.map(id => id + 1).join(', ')}„ÄÇËØ∑ÊäïÁ•®„ÄÇ`, "public");
                let votes = {};
                const voters = players.filter(p => p.alive && !candidates.includes(p.id));

                if (voters.length === 0) {
                    addLog("ÊâÄÊúâ‰∫∫ÈÉΩÁ´ûÈÄâ‰∫ÜÔºåÊó†Ê≥ïÊäïÁ•®ÔºåË≠¶ÂæΩÊµÅÂ§±„ÄÇ", "public");
                } else {
                    for (const p of voters) {
                        const cList = candidates.map(id => `${id + 1}Âè∑`).join(', ');
                        const raw = await streamLLM(p, 'sheriff_vote', `ÂÄôÈÄâ‰∫∫Ôºö${cList}„ÄÇËØ∑ÊäïÁ•® (vote)„ÄÇ`);
                        const j = processAndLogResponse(p.id, p.role, raw, true);
                        if (j && j.target !== undefined) {
                            const t = parseInt(j.target);
                            if (candidates.includes(t)) {
                                votes[t] = (votes[t] || 0) + 1;
                                addLog(`üó≥Ô∏è ${p.id + 1}Âè∑ ÊäïÁªô‰∫Ü ${t + 1}Âè∑`, "public");
                            }
                        }
                    }
                    // Tally
                    const s = Object.entries(votes).sort((a, b) => b[1] - a[1]);
                    console.log("Election Votes:", votes, "Sorted:", s); // Debug Log

                    if (s.length > 0 && (s.length === 1 || s[0][1] > s[1][1])) {
                        const winner = parseInt(s[0][0]);
                        gameState.sheriffId = winner;
                        players[winner].isSheriff = true;
                        addLog(`${winner + 1}Âè∑ ÂΩìÈÄâË≠¶ÈïøÔºÅ`, "public");
                    } else {
                        addLog("Âπ≥Á•®ÊàñÊó†‰∫∫ÊäïÁ•®ÔºåË≠¶ÂæΩÊµÅÂ§±„ÄÇ", "public");
                    }
                }
            }
            gameState.subPhase = 'discuss';
            updateHeader();
        }

        async function runDiscuss() {
            const a = players.filter(p => p.alive);
            // Sort speakers: Sheriff last
            if (gameState.sheriffId !== -1) {
                const sIdx = a.findIndex(p => p.id === gameState.sheriffId);
                if (sIdx !== -1) {
                    const sheriff = a.splice(sIdx, 1)[0];
                    a.push(sheriff);
                }
            }

            if (gameState.discussIdx < a.length) {
                const p = a[gameState.discussIdx];
                let promptKey = 'day_discuss';
                if (p.role === 'ÁôΩÁãºÁéã') promptKey = 'white_wolf_king_discuss';

                const raw = await streamLLM(p, promptKey, "ËØ∑ÂèëË®Ä„ÄÇ");
                const j = processAndLogResponse(p.id, p.role, raw, true); // Public log

                // White Wolf King Self-Destruct
                if (p.role === 'ÁôΩÁãºÁéã' && j && j.action === 'self_destruct' && j.target !== undefined) {
                    const t = parseInt(j.target);
                    addLog(`üí• ÁôΩÁãºÁéãËá™ÁàÜÔºÅÂ∏¶Ëµ∞‰∫Ü ${t + 1}Âè∑ÔºÅ`, "public");
                    kill(p.id); // King dies
                    if (players[t] && players[t].alive) {
                        await handleDeath(t);
                    }
                    // Skip to night
                    gameState.subPhase = 'wolf';
                    gameState.phase = 'night';
                    updateHeader();
                    return;
                }

                gameState.discussIdx++;
            } else gameState.subPhase = 'vote';
            updateHeader();
        }

        async function runVote() {
            addLog("=== ÊäïÁ•®Èò∂ÊÆµ ===", "sys");
            let v = {}; const a = players.filter(p => p.alive && p.canVote);
            for (const p of a) {
                const raw = await streamLLM(p, 'day_vote', "ËØ∑ÊäïÁ•®„ÄÇ");
                const j = processAndLogResponse(p.id, p.role, raw, true);
                let t = -1;
                if (j && j.target !== undefined) t = parseInt(j.target);
                else { const o = a.filter(x => x.id !== p.id); if (o.length) t = o[Math.floor(Math.random() * o.length)].id; } // fallback

                let weight = 1;
                if (p.isSheriff) {
                    weight = 1.5;
                    addLog(`üó≥Ô∏è ${p.id + 1}Âè∑(Ë≠¶Èïø) ÊäïÁªô‰∫Ü ${t + 1}Âè∑ (1.5Á•®)`, "public");
                } else {
                    addLog(`üó≥Ô∏è ${p.id + 1}Âè∑ ÊäïÁªô‰∫Ü ${t + 1}Âè∑`, "public");
                }

                v[t] = (v[t] || 0) + weight;
            }
            // Tally
            const s = Object.entries(v).sort((a, b) => b[1] - a[1]);
            if (s.length && s[0][1] > (s[1]?.[1] || 0)) {
                const o = parseInt(s[0][0]);

                // Idiot Reveal Logic
                if (players[o].role === 'ÁôΩÁó¥' && !players[o].isIdiotRevealed) {
                    addLog(`${o + 1}Âè∑ Ë¢´ÂÖ¨ÊäïÂá∫Â±Ä... Á≠âÁ≠âÔºÅ`, "public");
                    addLog(`ü§° ${o + 1}Âè∑ ÁøªÁâåÔºöÊàëÊòØÁôΩÁó¥ÔºÅÂÖçÁñ´Êú¨Ê¨°ÊîæÈÄêÔºÅ`, "public");
                    players[o].isIdiotRevealed = true;
                    players[o].canVote = false; // Lose vote right
                } else {
                    addLog(`${o + 1}Âè∑ Ë¢´ÂÖ¨ÊäïÂá∫Â±Ä„ÄÇ`, "public");
                    await handleDeath(o);
                }
            } else addLog("Âπ≥Á•®ÔºåÊó†‰∫∫Âá∫Â±Ä„ÄÇ", "public");

            gameState.dayCount++;
            gameState.subPhase = 'wolf';
            gameState.phase = 'night';
            updateHeader();
        }

        async function runReview() {
            if (!gameState.reviewRound) gameState.reviewRound = 1;
            const maxReviewRounds = 2;

            if (gameState.reviewRound > maxReviewRounds) {
                addLog("=== Â§çÁõòÁªìÊùü ===", "sys");
                gameState.status = 'ended'; // Final end
                document.getElementById('autoPlay').checked = false;
                return;
            }

            addLog(`=== ËµõÂêéÂ§çÁõò Á¨¨ ${gameState.reviewRound} ËΩÆ ===`, "sys");

            // Reveal all roles for the prompt
            const allRoles = players.map(p => `${p.id + 1}Âè∑(${p.role})`).join(', ');

            for (const p of players) {
                // Even dead players speak in review
                const instruct = `ÊâÄÊúâÁé©ÂÆ∂Ë∫´‰ªΩÂ∑≤ÂÖ¨ÂºÄÔºö${allRoles}„ÄÇËØ∑ÁÇπËØÑÊú¨Â±ÄÊ∏∏ÊàèÔºåÂàÜÊûêËÉúË¥üÂéüÂõ†ÔºåÊàñËÄÖËÅäËÅä‰Ω†ÁöÑÂøÉË∑ØÂéÜÁ®ã„ÄÇ`;
                const raw = await streamLLM(p, 'game_review', instruct);
                processAndLogResponse(p.id, p.role, raw, true);
            }

            gameState.reviewRound++;
            updateHeader();
        }

        /**
         * 7. HELPERS & UI UTILS
         */
        function kill(i) {
            if (players[i] && players[i].alive) {
                players[i].alive = false;
                // Lovers Logic
                if (players[i].isCouple) {
                    const partnerId = players[i].coupleId;
                    if (players[partnerId] && players[partnerId].alive) {
                        addLog(`üíî ${i + 1}Âè∑ Ê≠ª‰∫ÜÔºå${partnerId + 1}Âè∑ ÊÆâÊÉÖÈöè‰πãËÄåÂéª„ÄÇ`, "public");
                        kill(partnerId);
                    }
                }
                // Sheriff Transfer Logic (Simplified: Sheriff dies, badge lost for now, or implement transfer later)
                if (players[i].isSheriff) {
                    addLog(`üëÆ Ë≠¶Èïø ${i + 1}Âè∑ Ê≠ª‰∫°ÔºåË≠¶ÂæΩÊµÅÂ§±ÔºàÊöÇÊú™ÂÆûÁé∞Áßª‰∫§Ôºâ„ÄÇ`, "public");
                    players[i].isSheriff = false;
                    gameState.sheriffId = -1;
                }
            }
        }
        function gameOver(g) {
            gameState.status = 'gameover'; // Mark as gameover but continue to review
            const m = g ? "üèÜ Â•Ω‰∫∫ËÉúÂà©" : "üåô Áãº‰∫∫ËÉúÂà©";
            addLog(m, "sys");

            // Transition to Review
            gameState.subPhase = 'review';
            gameState.reviewRound = 1;
            updateHeader();

            // If auto-play is on, it will continue to review in next gameStep
            // If not, user can click "Next Step"
        }
        function clearLogs() { document.getElementById('gameLog').innerHTML = ''; }
        function escapeHtml(t) { if (!t) return ""; return t.replace(/&/g, "&").replace(/</g, "<").replace(/>/g, ">"); }
        function updateHeader() {
            const m = { 'cupid': '‰∏òÊØîÁâπ', 'wolf': 'Áãº‰∫∫', 'seer': 'È¢ÑË®Ä', 'witch': 'Â•≥Â∑´', 'guard': 'ÂÆàÂç´', 'election': 'Á´ûÈÄâ', 'discuss': 'ÂèëË®Ä', 'vote': 'ÊäïÁ•®', 'review': 'Â§çÁõò' };
            document.getElementById('phaseDisplay').innerText = `Day ${gameState.dayCount} ¬∑ ${m[gameState.subPhase] || ''}`;
        }
        function getAvatar(r) { return { 'Áãº‰∫∫': 'üê∫', 'ÁôΩÁãºÁéã': 'üê∫üëë', 'ÊùëÊ∞ë': 'üë±', 'È¢ÑË®ÄÂÆ∂': 'üîÆ', 'Â•≥Â∑´': 'üß™', 'Áåé‰∫∫': 'üî´', 'ÂÆàÂç´': 'üõ°Ô∏è', '‰∏òÊØîÁâπ': 'üíò', 'ÁôΩÁó¥': 'ü§°' }[r] || '‚ùì'; }
        function toggleAuto() { const c = document.getElementById('autoPlay'); c.checked = !c.checked; if (c.checked) gameStep(); }

        // UI Builders
        function adjustPlayerCount(delta) {
            const current = appConfig.rolesSetup.length;
            const next = current + delta;
            if (next < 6 || next > 16) return;

            if (delta > 0) {
                appConfig.rolesSetup.push('ÊùëÊ∞ë');
                appConfig.modelsSetup.push(availableModels[0] || 'gpt-3.5-turbo');
            } else {
                appConfig.rolesSetup.pop();
                appConfig.modelsSetup.pop();
            }
            initRoleConfig();
        }

        function initRoleConfig() {
            const c = document.getElementById('roleConfigList');
            c.innerHTML = '';
            const count = appConfig.rolesSetup.length;
            document.getElementById('playerCountDisplay').innerText = count;

            for (let i = 0; i < count; i++) {
                c.innerHTML += `
        <div class="flex gap-1 items-center bg-black/20 p-1 rounded border border-gray-700">
            <span class="text-xs text-gray-500 w-4 text-center">${i + 1}</span>
            <select id="role-${i}" onchange="appConfig.rolesSetup[${i}]=this.value; saveGlobalSettings();" class="bg-gray-900 text-[10px] rounded p-1 text-pink-400 border border-gray-600 w-16">
                ${['Áãº‰∫∫', 'ÁôΩÁãºÁéã', 'ÊùëÊ∞ë', 'È¢ÑË®ÄÂÆ∂', 'Â•≥Â∑´', 'Áåé‰∫∫', 'ÂÆàÂç´', '‰∏òÊØîÁâπ', 'ÁôΩÁó¥'].map(x => `<option value="${x}"${appConfig.rolesSetup[i] === x ? 'selected' : ''}>${x}</option>`).join('')}
            </select>
            <select id="model-${i}" onchange="appConfig.modelsSetup[${i}]=this.value; saveGlobalSettings();" class="bg-gray-900 text-[10px] rounded p-1 text-blue-300 border border-gray-600 flex-1 w-24 truncate">
                ${availableModels.map(x => `<option value="${x}"${appConfig.modelsSetup[i] === x ? 'selected' : ''}>${x}</option>`).join('')}
            </select>
        </div>`;
            }
        }

        function updatePromptEditorList() {
            const s = document.getElementById('promptSelect'); s.innerHTML = '';
            Object.keys(appConfig.prompts).forEach(k => {
                s.innerHTML += `<option value="${k}">${k}</option>`;
            });
            loadPromptToEdit();
        }
        function loadPromptToEdit() {
            const k = document.getElementById('promptSelect').value;
            document.getElementById('promptText').value = appConfig.prompts[k];
        }
        function saveCurrentPrompt() {
            const k = document.getElementById('promptSelect').value;
            appConfig.prompts[k] = document.getElementById('promptText').value;
            // saveGlobalSettings(); // No longer auto-save to config, user must save preset
        }

        async function resetPrompts(updateUI = true) {
            try {
                const res = await fetch('/api/default_prompt');
                appConfig.prompts = await res.json();
                if (updateUI) {
                    updatePromptEditorList();
                    alert("Â∑≤ÊÅ¢Â§çÈªòËÆ§ Prompt");
                }
            } catch (e) { console.error("Failed to load default prompt"); }
        }

        // Preset Management
        async function refreshPresetList() {
            const s = document.getElementById('presetSelect');
            s.innerHTML = '<option value="">-- ÈÄâÊã©È¢ÑËÆæ --</option>';
            try {
                const res = await fetch('/api/presets');
                const files = await res.json();
                files.forEach(f => {
                    s.innerHTML += `<option value="${f}">${f}</option>`;
                });
            } catch (e) { }
        }

        async function loadPreset() {
            const name = document.getElementById('presetSelect').value;
            if (!name) return;
            try {
                const res = await fetch(`/api/presets/${name}`);
                appConfig.prompts = await res.json();
                updatePromptEditorList();
                alert(`Â∑≤Âä†ËΩΩÈ¢ÑËÆæ: ${name}`);
            } catch (e) { alert("Âä†ËΩΩÂ§±Ë¥•"); }
        }

        async function savePreset() {
            const name = prompt("ËØ∑ËæìÂÖ•È¢ÑËÆæÂêçÁß∞ (‰æãÂ¶Ç: my_custom_prompts):");
            if (!name) return;
            try {
                await fetch(`/api/presets/${name}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(appConfig.prompts)
                });
                refreshPresetList();
                alert("È¢ÑËÆæ‰øùÂ≠òÊàêÂäü!");
            } catch (e) { alert("‰øùÂ≠òÂ§±Ë¥•"); }
        }

        async function deletePreset() {
            const name = document.getElementById('presetSelect').value;
            if (!name) return;
            if (!confirm(`Á°ÆÂÆöÂà†Èô§È¢ÑËÆæ ${name}?`)) return;
            try {
                await fetch(`/api/presets/${name}`, { method: 'DELETE' });
                refreshPresetList();
            } catch (e) { alert("Âà†Èô§Â§±Ë¥•"); }
        }

        async function fetchModels() {
            try {
                const r = await fetch(`${appConfig.apiBase}/models`, { headers: { 'Authorization': `Bearer ${appConfig.apiKey}` } });
                const d = await r.json();
                availableModels = d.data.map(m => m.id);
                initRoleConfig();
                alert(`Â∑≤Âà∑Êñ∞ ${availableModels.length} ‰∏™Ê®°Âûã`);
            } catch (e) { alert("Ëé∑ÂèñÊ®°ÂûãÂ§±Ë¥•"); }
        }

        function toggleSettings() { document.getElementById('settingsModal').classList.toggle('active'); }
        function renderGrid() {
            const g = document.getElementById('playersGrid'); g.innerHTML = '';
            players.forEach(p => {
                g.innerHTML += `
        <div id="card-${p.id}" class="role-card rounded p-2 flex flex-col items-center justify-center aspect-square relative bg-gray-800 ${!p.alive ? 'dead' : ''}">
            <div class="text-2xl mb-1">${p.alive ? p.avatar : 'üíÄ'}</div>
            <div class="text-[10px] ${p.role === 'Áãº‰∫∫' ? 'text-red-400' : 'text-blue-300'}">${p.role}</div>
            <div class="absolute top-0 left-1 text-[9px] opacity-50">#${p.id + 1}</div>
        </div>`;
            });
        }

        // Start
        init();
    </script>
</body>

</html>